{
  "version": 3,
  "sources": ["../../node_modules/echarts/lib/label/labelLayoutHelper.js"],
  "sourcesContent": ["\r\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\r\n\r\n\r\n/**\r\n * AUTO-GENERATED FILE. DO NOT MODIFY.\r\n */\r\n\r\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\r\nimport { BoundingRect, OrientedBoundingRect } from '../util/graphic.js';\r\nexport function prepareLayoutList(input) {\r\n  var list = [];\r\n\r\n  for (var i = 0; i < input.length; i++) {\r\n    var rawItem = input[i];\r\n\r\n    if (rawItem.defaultAttr.ignore) {\r\n      continue;\r\n    }\r\n\r\n    var label = rawItem.label;\r\n    var transform = label.getComputedTransform(); // NOTE: Get bounding rect after getComputedTransform, or label may not been updated by the host el.\r\n\r\n    var localRect = label.getBoundingRect();\r\n    var isAxisAligned = !transform || transform[1] < 1e-5 && transform[2] < 1e-5;\r\n    var minMargin = label.style.margin || 0;\r\n    var globalRect = localRect.clone();\r\n    globalRect.applyTransform(transform);\r\n    globalRect.x -= minMargin / 2;\r\n    globalRect.y -= minMargin / 2;\r\n    globalRect.width += minMargin;\r\n    globalRect.height += minMargin;\r\n    var obb = isAxisAligned ? new OrientedBoundingRect(localRect, transform) : null;\r\n    list.push({\r\n      label: label,\r\n      labelLine: rawItem.labelLine,\r\n      rect: globalRect,\r\n      localRect: localRect,\r\n      obb: obb,\r\n      priority: rawItem.priority,\r\n      defaultAttr: rawItem.defaultAttr,\r\n      layoutOption: rawItem.computedLayoutOption,\r\n      axisAligned: isAxisAligned,\r\n      transform: transform\r\n    });\r\n  }\r\n\r\n  return list;\r\n}\r\n\r\nfunction shiftLayout(list, xyDim, sizeDim, minBound, maxBound, balanceShift) {\r\n  var len = list.length;\r\n\r\n  if (len < 2) {\r\n    return;\r\n  }\r\n\r\n  list.sort(function (a, b) {\r\n    return a.rect[xyDim] - b.rect[xyDim];\r\n  });\r\n  var lastPos = 0;\r\n  var delta;\r\n  var adjusted = false;\r\n  var shifts = [];\r\n  var totalShifts = 0;\r\n\r\n  for (var i = 0; i < len; i++) {\r\n    var item = list[i];\r\n    var rect = item.rect;\r\n    delta = rect[xyDim] - lastPos;\r\n\r\n    if (delta < 0) {\r\n      // shiftForward(i, len, -delta);\r\n      rect[xyDim] -= delta;\r\n      item.label[xyDim] -= delta;\r\n      adjusted = true;\r\n    }\r\n\r\n    var shift = Math.max(-delta, 0);\r\n    shifts.push(shift);\r\n    totalShifts += shift;\r\n    lastPos = rect[xyDim] + rect[sizeDim];\r\n  }\r\n\r\n  if (totalShifts > 0 && balanceShift) {\r\n    // Shift back to make the distribution more equally.\r\n    shiftList(-totalShifts / len, 0, len);\r\n  } // TODO bleedMargin?\r\n\r\n\r\n  var first = list[0];\r\n  var last = list[len - 1];\r\n  var minGap;\r\n  var maxGap;\r\n  updateMinMaxGap(); // If ends exceed two bounds, squeeze at most 80%, then take the gap of two bounds.\r\n\r\n  minGap < 0 && squeezeGaps(-minGap, 0.8);\r\n  maxGap < 0 && squeezeGaps(maxGap, 0.8);\r\n  updateMinMaxGap();\r\n  takeBoundsGap(minGap, maxGap, 1);\r\n  takeBoundsGap(maxGap, minGap, -1); // Handle bailout when there is not enough space.\r\n\r\n  updateMinMaxGap();\r\n\r\n  if (minGap < 0) {\r\n    squeezeWhenBailout(-minGap);\r\n  }\r\n\r\n  if (maxGap < 0) {\r\n    squeezeWhenBailout(maxGap);\r\n  }\r\n\r\n  function updateMinMaxGap() {\r\n    minGap = first.rect[xyDim] - minBound;\r\n    maxGap = maxBound - last.rect[xyDim] - last.rect[sizeDim];\r\n  }\r\n\r\n  function takeBoundsGap(gapThisBound, gapOtherBound, moveDir) {\r\n    if (gapThisBound < 0) {\r\n      // Move from other gap if can.\r\n      var moveFromMaxGap = Math.min(gapOtherBound, -gapThisBound);\r\n\r\n      if (moveFromMaxGap > 0) {\r\n        shiftList(moveFromMaxGap * moveDir, 0, len);\r\n        var remained = moveFromMaxGap + gapThisBound;\r\n\r\n        if (remained < 0) {\r\n          squeezeGaps(-remained * moveDir, 1);\r\n        }\r\n      } else {\r\n        squeezeGaps(-gapThisBound * moveDir, 1);\r\n      }\r\n    }\r\n  }\r\n\r\n  function shiftList(delta, start, end) {\r\n    if (delta !== 0) {\r\n      adjusted = true;\r\n    }\r\n\r\n    for (var i = start; i < end; i++) {\r\n      var item = list[i];\r\n      var rect = item.rect;\r\n      rect[xyDim] += delta;\r\n      item.label[xyDim] += delta;\r\n    }\r\n  } // Squeeze gaps if the labels exceed margin.\r\n\r\n\r\n  function squeezeGaps(delta, maxSqeezePercent) {\r\n    var gaps = [];\r\n    var totalGaps = 0;\r\n\r\n    for (var i = 1; i < len; i++) {\r\n      var prevItemRect = list[i - 1].rect;\r\n      var gap = Math.max(list[i].rect[xyDim] - prevItemRect[xyDim] - prevItemRect[sizeDim], 0);\r\n      gaps.push(gap);\r\n      totalGaps += gap;\r\n    }\r\n\r\n    if (!totalGaps) {\r\n      return;\r\n    }\r\n\r\n    var squeezePercent = Math.min(Math.abs(delta) / totalGaps, maxSqeezePercent);\r\n\r\n    if (delta > 0) {\r\n      for (var i = 0; i < len - 1; i++) {\r\n        // Distribute the shift delta to all gaps.\r\n        var movement = gaps[i] * squeezePercent; // Forward\r\n\r\n        shiftList(movement, 0, i + 1);\r\n      }\r\n    } else {\r\n      // Backward\r\n      for (var i = len - 1; i > 0; i--) {\r\n        // Distribute the shift delta to all gaps.\r\n        var movement = gaps[i - 1] * squeezePercent;\r\n        shiftList(-movement, i, len);\r\n      }\r\n    }\r\n  }\r\n  /**\r\n   * Squeeze to allow overlap if there is no more space available.\r\n   * Let other overlapping strategy like hideOverlap do the job instead of keep exceeding the bounds.\r\n   */\r\n\r\n\r\n  function squeezeWhenBailout(delta) {\r\n    var dir = delta < 0 ? -1 : 1;\r\n    delta = Math.abs(delta);\r\n    var moveForEachLabel = Math.ceil(delta / (len - 1));\r\n\r\n    for (var i = 0; i < len - 1; i++) {\r\n      if (dir > 0) {\r\n        // Forward\r\n        shiftList(moveForEachLabel, 0, i + 1);\r\n      } else {\r\n        // Backward\r\n        shiftList(-moveForEachLabel, len - i - 1, len);\r\n      }\r\n\r\n      delta -= moveForEachLabel;\r\n\r\n      if (delta <= 0) {\r\n        return;\r\n      }\r\n    }\r\n  }\r\n\r\n  return adjusted;\r\n}\r\n/**\r\n * Adjust labels on x direction to avoid overlap.\r\n */\r\n\r\n\r\nexport function shiftLayoutOnX(list, leftBound, rightBound, // If average the shifts on all labels and add them to 0\r\n// TODO: Not sure if should enable it.\r\n// Pros: The angle of lines will distribute more equally\r\n// Cons: In some layout. It may not what user wanted. like in pie. the label of last sector is usually changed unexpectedly.\r\nbalanceShift) {\r\n  return shiftLayout(list, 'x', 'width', leftBound, rightBound, balanceShift);\r\n}\r\n/**\r\n * Adjust labels on y direction to avoid overlap.\r\n */\r\n\r\nexport function shiftLayoutOnY(list, topBound, bottomBound, // If average the shifts on all labels and add them to 0\r\nbalanceShift) {\r\n  return shiftLayout(list, 'y', 'height', topBound, bottomBound, balanceShift);\r\n}\r\nexport function hideOverlap(labelList) {\r\n  var displayedLabels = []; // TODO, render overflow visible first, put in the displayedLabels.\r\n\r\n  labelList.sort(function (a, b) {\r\n    return b.priority - a.priority;\r\n  });\r\n  var globalRect = new BoundingRect(0, 0, 0, 0);\r\n\r\n  function hideEl(el) {\r\n    if (!el.ignore) {\r\n      // Show on emphasis.\r\n      var emphasisState = el.ensureState('emphasis');\r\n\r\n      if (emphasisState.ignore == null) {\r\n        emphasisState.ignore = false;\r\n      }\r\n    }\r\n\r\n    el.ignore = true;\r\n  }\r\n\r\n  for (var i = 0; i < labelList.length; i++) {\r\n    var labelItem = labelList[i];\r\n    var isAxisAligned = labelItem.axisAligned;\r\n    var localRect = labelItem.localRect;\r\n    var transform = labelItem.transform;\r\n    var label = labelItem.label;\r\n    var labelLine = labelItem.labelLine;\r\n    globalRect.copy(labelItem.rect); // Add a threshold because layout may be aligned precisely.\r\n\r\n    globalRect.width -= 0.1;\r\n    globalRect.height -= 0.1;\r\n    globalRect.x += 0.05;\r\n    globalRect.y += 0.05;\r\n    var obb = labelItem.obb;\r\n    var overlapped = false;\r\n\r\n    for (var j = 0; j < displayedLabels.length; j++) {\r\n      var existsTextCfg = displayedLabels[j]; // Fast rejection.\r\n\r\n      if (!globalRect.intersect(existsTextCfg.rect)) {\r\n        continue;\r\n      }\r\n\r\n      if (isAxisAligned && existsTextCfg.axisAligned) {\r\n        // Is overlapped\r\n        overlapped = true;\r\n        break;\r\n      }\r\n\r\n      if (!existsTextCfg.obb) {\r\n        // If self is not axis aligned. But other is.\r\n        existsTextCfg.obb = new OrientedBoundingRect(existsTextCfg.localRect, existsTextCfg.transform);\r\n      }\r\n\r\n      if (!obb) {\r\n        // If self is axis aligned. But other is not.\r\n        obb = new OrientedBoundingRect(localRect, transform);\r\n      }\r\n\r\n      if (obb.intersect(existsTextCfg.obb)) {\r\n        overlapped = true;\r\n        break;\r\n      }\r\n    } // TODO Callback to determine if this overlap should be handled?\r\n\r\n\r\n    if (overlapped) {\r\n      hideEl(label);\r\n      labelLine && hideEl(labelLine);\r\n    } else {\r\n      label.attr('ignore', labelItem.defaultAttr.ignore);\r\n      labelLine && labelLine.attr('ignore', labelItem.defaultAttr.labelGuideIgnore);\r\n      displayedLabels.push(labelItem);\r\n    }\r\n  }\r\n}"],
  "mappings": "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",
  "names": ["delta", "i", "item", "rect"]
}
