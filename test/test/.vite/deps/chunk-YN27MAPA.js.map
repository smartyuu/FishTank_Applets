{
  "version": 3,
  "sources": ["../../node_modules/echarts/lib/data/helper/dimensionHelper.js", "../../node_modules/echarts/lib/data/SeriesDimensionDefine.js", "../../node_modules/echarts/lib/data/SeriesData.js"],
  "sourcesContent": ["\r\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\r\n\r\n\r\n/**\r\n * AUTO-GENERATED FILE. DO NOT MODIFY.\r\n */\r\n\r\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\r\nimport { each, createHashMap, assert, map } from 'zrender/lib/core/util.js';\r\nimport { VISUAL_DIMENSIONS } from '../../util/types.js';\r\n\r\nvar DimensionUserOuput =\r\n/** @class */\r\nfunction () {\r\n  function DimensionUserOuput(encode, dimRequest) {\r\n    this._encode = encode;\r\n    this._schema = dimRequest;\r\n  }\r\n\r\n  DimensionUserOuput.prototype.get = function () {\r\n    return {\r\n      // Do not generate full dimension name until fist used.\r\n      fullDimensions: this._getFullDimensionNames(),\r\n      encode: this._encode\r\n    };\r\n  };\r\n  /**\r\n   * Get all data store dimension names.\r\n   * Theoretically a series data store is defined both by series and used dataset (if any).\r\n   * If some dimensions are omitted for performance reason in `this.dimensions`,\r\n   * the dimension name may not be auto-generated if user does not specify a dimension name.\r\n   * In this case, the dimension name is `null`/`undefined`.\r\n   */\r\n\r\n\r\n  DimensionUserOuput.prototype._getFullDimensionNames = function () {\r\n    if (!this._cachedDimNames) {\r\n      this._cachedDimNames = this._schema ? this._schema.makeOutputDimensionNames() : [];\r\n    }\r\n\r\n    return this._cachedDimNames;\r\n  };\r\n\r\n  return DimensionUserOuput;\r\n}();\r\n\r\n;\r\nexport function summarizeDimensions(data, schema) {\r\n  var summary = {};\r\n  var encode = summary.encode = {};\r\n  var notExtraCoordDimMap = createHashMap();\r\n  var defaultedLabel = [];\r\n  var defaultedTooltip = [];\r\n  var userOutputEncode = {};\r\n  each(data.dimensions, function (dimName) {\r\n    var dimItem = data.getDimensionInfo(dimName);\r\n    var coordDim = dimItem.coordDim;\r\n\r\n    if (coordDim) {\r\n      if (process.env.NODE_ENV !== 'production') {\r\n        assert(VISUAL_DIMENSIONS.get(coordDim) == null);\r\n      }\r\n\r\n      var coordDimIndex = dimItem.coordDimIndex;\r\n      getOrCreateEncodeArr(encode, coordDim)[coordDimIndex] = dimName;\r\n\r\n      if (!dimItem.isExtraCoord) {\r\n        notExtraCoordDimMap.set(coordDim, 1); // Use the last coord dim (and label friendly) as default label,\r\n        // because when dataset is used, it is hard to guess which dimension\r\n        // can be value dimension. If both show x, y on label is not look good,\r\n        // and conventionally y axis is focused more.\r\n\r\n        if (mayLabelDimType(dimItem.type)) {\r\n          defaultedLabel[0] = dimName;\r\n        } // User output encode do not contain generated coords.\r\n        // And it only has index. User can use index to retrieve value from the raw item array.\r\n\r\n\r\n        getOrCreateEncodeArr(userOutputEncode, coordDim)[coordDimIndex] = data.getDimensionIndex(dimItem.name);\r\n      }\r\n\r\n      if (dimItem.defaultTooltip) {\r\n        defaultedTooltip.push(dimName);\r\n      }\r\n    }\r\n\r\n    VISUAL_DIMENSIONS.each(function (v, otherDim) {\r\n      var encodeArr = getOrCreateEncodeArr(encode, otherDim);\r\n      var dimIndex = dimItem.otherDims[otherDim];\r\n\r\n      if (dimIndex != null && dimIndex !== false) {\r\n        encodeArr[dimIndex] = dimItem.name;\r\n      }\r\n    });\r\n  });\r\n  var dataDimsOnCoord = [];\r\n  var encodeFirstDimNotExtra = {};\r\n  notExtraCoordDimMap.each(function (v, coordDim) {\r\n    var dimArr = encode[coordDim];\r\n    encodeFirstDimNotExtra[coordDim] = dimArr[0]; // Not necessary to remove duplicate, because a data\r\n    // dim canot on more than one coordDim.\r\n\r\n    dataDimsOnCoord = dataDimsOnCoord.concat(dimArr);\r\n  });\r\n  summary.dataDimsOnCoord = dataDimsOnCoord;\r\n  summary.dataDimIndicesOnCoord = map(dataDimsOnCoord, function (dimName) {\r\n    return data.getDimensionInfo(dimName).storeDimIndex;\r\n  });\r\n  summary.encodeFirstDimNotExtra = encodeFirstDimNotExtra;\r\n  var encodeLabel = encode.label; // FIXME `encode.label` is not recommended, because formatter cannot be set\r\n  // in this way. Use label.formatter instead. Maybe remove this approach someday.\r\n\r\n  if (encodeLabel && encodeLabel.length) {\r\n    defaultedLabel = encodeLabel.slice();\r\n  }\r\n\r\n  var encodeTooltip = encode.tooltip;\r\n\r\n  if (encodeTooltip && encodeTooltip.length) {\r\n    defaultedTooltip = encodeTooltip.slice();\r\n  } else if (!defaultedTooltip.length) {\r\n    defaultedTooltip = defaultedLabel.slice();\r\n  }\r\n\r\n  encode.defaultedLabel = defaultedLabel;\r\n  encode.defaultedTooltip = defaultedTooltip;\r\n  summary.userOutput = new DimensionUserOuput(userOutputEncode, schema);\r\n  return summary;\r\n}\r\n\r\nfunction getOrCreateEncodeArr(encode, dim) {\r\n  if (!encode.hasOwnProperty(dim)) {\r\n    encode[dim] = [];\r\n  }\r\n\r\n  return encode[dim];\r\n} // FIXME:TS should be type `AxisType`\r\n\r\n\r\nexport function getDimensionTypeByAxis(axisType) {\r\n  return axisType === 'category' ? 'ordinal' : axisType === 'time' ? 'time' : 'float';\r\n}\r\n\r\nfunction mayLabelDimType(dimType) {\r\n  // In most cases, ordinal and time do not suitable for label.\r\n  // Ordinal info can be displayed on axis. Time is too long.\r\n  return !(dimType === 'ordinal' || dimType === 'time');\r\n} // function findTheLastDimMayLabel(data) {\r\n//     // Get last value dim\r\n//     let dimensions = data.dimensions.slice();\r\n//     let valueType;\r\n//     let valueDim;\r\n//     while (dimensions.length && (\r\n//         valueDim = dimensions.pop(),\r\n//         valueType = data.getDimensionInfo(valueDim).type,\r\n//         valueType === 'ordinal' || valueType === 'time'\r\n//     )) {} // jshint ignore:line\r\n//     return valueDim;\r\n// }", "\r\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\r\n\r\n\r\n/**\r\n * AUTO-GENERATED FILE. DO NOT MODIFY.\r\n */\r\n\r\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\r\nimport * as zrUtil from 'zrender/lib/core/util.js';\r\n\r\nvar SeriesDimensionDefine =\r\n/** @class */\r\nfunction () {\r\n  /**\r\n   * @param opt All of the fields will be shallow copied.\r\n   */\r\n  function SeriesDimensionDefine(opt) {\r\n    /**\r\n     * The format of `otherDims` is:\r\n     * ```js\r\n     * {\r\n     *     tooltip?: number\r\n     *     label?: number\r\n     *     itemName?: number\r\n     *     seriesName?: number\r\n     * }\r\n     * ```\r\n     *\r\n     * A `series.encode` can specified these fields:\r\n     * ```js\r\n     * encode: {\r\n     *     // \"3, 1, 5\" is the index of data dimension.\r\n     *     tooltip: [3, 1, 5],\r\n     *     label: [0, 3],\r\n     *     ...\r\n     * }\r\n     * ```\r\n     * `otherDims` is the parse result of the `series.encode` above, like:\r\n     * ```js\r\n     * // Suppose the index of this data dimension is `3`.\r\n     * this.otherDims = {\r\n     *     // `3` is at the index `0` of the `encode.tooltip`\r\n     *     tooltip: 0,\r\n     *     // `3` is at the index `1` of the `encode.label`\r\n     *     label: 1\r\n     * };\r\n     * ```\r\n     *\r\n     * This prop should never be `null`/`undefined` after initialized.\r\n     */\r\n    this.otherDims = {};\r\n\r\n    if (opt != null) {\r\n      zrUtil.extend(this, opt);\r\n    }\r\n  }\r\n\r\n  return SeriesDimensionDefine;\r\n}();\r\n\r\n;\r\nexport default SeriesDimensionDefine;", "\r\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\r\n\r\n\r\n/**\r\n * AUTO-GENERATED FILE. DO NOT MODIFY.\r\n */\r\n\r\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\r\n\r\n/* global Int32Array */\r\nimport * as zrUtil from 'zrender/lib/core/util.js';\r\nimport Model from '../model/Model.js';\r\nimport DataDiffer from './DataDiffer.js';\r\nimport { DefaultDataProvider } from './helper/dataProvider.js';\r\nimport { summarizeDimensions } from './helper/dimensionHelper.js';\r\nimport SeriesDimensionDefine from './SeriesDimensionDefine.js';\r\nimport { SOURCE_FORMAT_TYPED_ARRAY, SOURCE_FORMAT_ORIGINAL } from '../util/types.js';\r\nimport { convertOptionIdName, isDataItemOption } from '../util/model.js';\r\nimport { setCommonECData } from '../util/innerStore.js';\r\nimport { isSourceInstance } from './Source.js';\r\nimport DataStore from './DataStore.js';\r\nimport { isSeriesDataSchema } from './helper/SeriesDataSchema.js';\r\nvar isObject = zrUtil.isObject;\r\nvar map = zrUtil.map;\r\nvar CtorInt32Array = typeof Int32Array === 'undefined' ? Array : Int32Array; // Use prefix to avoid index to be the same as otherIdList[idx],\r\n// which will cause weird update animation.\r\n\r\nvar ID_PREFIX = 'e\\0\\0';\r\nvar INDEX_NOT_FOUND = -1; // type SeriesDimensionIndex = DimensionIndex;\r\n\r\nvar TRANSFERABLE_PROPERTIES = ['hasItemOption', '_nameList', '_idList', '_invertedIndicesMap', '_dimSummary', 'userOutput', '_rawData', '_dimValueGetter', '_nameDimIdx', '_idDimIdx', '_nameRepeatCount'];\r\nvar CLONE_PROPERTIES = ['_approximateExtent']; // -----------------------------\r\n// Internal method declarations:\r\n// -----------------------------\r\n\r\nvar prepareInvertedIndex;\r\nvar getId;\r\nvar getIdNameFromStore;\r\nvar normalizeDimensions;\r\nvar transferProperties;\r\nvar cloneListForMapAndSample;\r\nvar makeIdFromName;\r\n\r\nvar SeriesData =\r\n/** @class */\r\nfunction () {\r\n  /**\r\n   * @param dimensionsInput.dimensions\r\n   *        For example, ['someDimName', {name: 'someDimName', type: 'someDimType'}, ...].\r\n   *        Dimensions should be concrete names like x, y, z, lng, lat, angle, radius\r\n   */\r\n  function SeriesData(dimensionsInput, hostModel) {\r\n    this.type = 'list';\r\n    this._dimOmitted = false;\r\n    this._nameList = [];\r\n    this._idList = []; // Models of data option is stored sparse for optimizing memory cost\r\n    // Never used yet (not used yet).\r\n    // private _optionModels: Model[] = [];\r\n    // Global visual properties after visual coding\r\n\r\n    this._visual = {}; // Global layout properties.\r\n\r\n    this._layout = {}; // Item visual properties after visual coding\r\n\r\n    this._itemVisuals = []; // Item layout properties after layout\r\n\r\n    this._itemLayouts = []; // Graphic elements\r\n\r\n    this._graphicEls = []; // key: dim, value: extent\r\n\r\n    this._approximateExtent = {};\r\n    this._calculationInfo = {}; // Having detected that there is data item is non primitive type\r\n    // (in type `OptionDataItemObject`).\r\n    // Like `data: [ { value: xx, itemStyle: {...} }, ...]`\r\n    // At present it only happen in `SOURCE_FORMAT_ORIGINAL`.\r\n\r\n    this.hasItemOption = false; // Methods that create a new list based on this list should be listed here.\r\n    // Notice that those method should `RETURN` the new list.\r\n\r\n    this.TRANSFERABLE_METHODS = ['cloneShallow', 'downSample', 'lttbDownSample', 'map']; // Methods that change indices of this list should be listed here.\r\n\r\n    this.CHANGABLE_METHODS = ['filterSelf', 'selectRange'];\r\n    this.DOWNSAMPLE_METHODS = ['downSample', 'lttbDownSample'];\r\n    var dimensions;\r\n    var assignStoreDimIdx = false;\r\n\r\n    if (isSeriesDataSchema(dimensionsInput)) {\r\n      dimensions = dimensionsInput.dimensions;\r\n      this._dimOmitted = dimensionsInput.isDimensionOmitted();\r\n      this._schema = dimensionsInput;\r\n    } else {\r\n      assignStoreDimIdx = true;\r\n      dimensions = dimensionsInput;\r\n    }\r\n\r\n    dimensions = dimensions || ['x', 'y'];\r\n    var dimensionInfos = {};\r\n    var dimensionNames = [];\r\n    var invertedIndicesMap = {};\r\n    var needsHasOwn = false;\r\n    var emptyObj = {};\r\n\r\n    for (var i = 0; i < dimensions.length; i++) {\r\n      // Use the original dimensions[i], where other flag props may exists.\r\n      var dimInfoInput = dimensions[i];\r\n      var dimensionInfo = zrUtil.isString(dimInfoInput) ? new SeriesDimensionDefine({\r\n        name: dimInfoInput\r\n      }) : !(dimInfoInput instanceof SeriesDimensionDefine) ? new SeriesDimensionDefine(dimInfoInput) : dimInfoInput;\r\n      var dimensionName = dimensionInfo.name;\r\n      dimensionInfo.type = dimensionInfo.type || 'float';\r\n\r\n      if (!dimensionInfo.coordDim) {\r\n        dimensionInfo.coordDim = dimensionName;\r\n        dimensionInfo.coordDimIndex = 0;\r\n      }\r\n\r\n      var otherDims = dimensionInfo.otherDims = dimensionInfo.otherDims || {};\r\n      dimensionNames.push(dimensionName);\r\n      dimensionInfos[dimensionName] = dimensionInfo;\r\n\r\n      if (emptyObj[dimensionName] != null) {\r\n        needsHasOwn = true;\r\n      }\r\n\r\n      if (dimensionInfo.createInvertedIndices) {\r\n        invertedIndicesMap[dimensionName] = [];\r\n      }\r\n\r\n      if (otherDims.itemName === 0) {\r\n        this._nameDimIdx = i;\r\n      }\r\n\r\n      if (otherDims.itemId === 0) {\r\n        this._idDimIdx = i;\r\n      }\r\n\r\n      if (process.env.NODE_ENV !== 'production') {\r\n        zrUtil.assert(assignStoreDimIdx || dimensionInfo.storeDimIndex >= 0);\r\n      }\r\n\r\n      if (assignStoreDimIdx) {\r\n        dimensionInfo.storeDimIndex = i;\r\n      }\r\n    }\r\n\r\n    this.dimensions = dimensionNames;\r\n    this._dimInfos = dimensionInfos;\r\n\r\n    this._initGetDimensionInfo(needsHasOwn);\r\n\r\n    this.hostModel = hostModel;\r\n    this._invertedIndicesMap = invertedIndicesMap;\r\n\r\n    if (this._dimOmitted) {\r\n      var dimIdxToName_1 = this._dimIdxToName = zrUtil.createHashMap();\r\n      zrUtil.each(dimensionNames, function (dimName) {\r\n        dimIdxToName_1.set(dimensionInfos[dimName].storeDimIndex, dimName);\r\n      });\r\n    }\r\n  }\r\n  /**\r\n   *\r\n   * Get concrete dimension name by dimension name or dimension index.\r\n   * If input a dimension name, do not validate whether the dimension name exits.\r\n   *\r\n   * @caution\r\n   * @param dim Must make sure the dimension is `SeriesDimensionLoose`.\r\n   * Because only those dimensions will have auto-generated dimension names if not\r\n   * have a user-specified name, and other dimensions will get a return of null/undefined.\r\n   *\r\n   * @notice Because of this reason, should better use `getDimensionIndex` instead, for examples:\r\n   * ```js\r\n   * const val = data.getStore().get(data.getDimensionIndex(dim), dataIdx);\r\n   * ```\r\n   *\r\n   * @return Concrete dim name.\r\n   */\r\n\r\n\r\n  SeriesData.prototype.getDimension = function (dim) {\r\n    var dimIdx = this._recognizeDimIndex(dim);\r\n\r\n    if (dimIdx == null) {\r\n      return dim;\r\n    }\r\n\r\n    dimIdx = dim;\r\n\r\n    if (!this._dimOmitted) {\r\n      return this.dimensions[dimIdx];\r\n    } // Retrieve from series dimension definition because it probably contains\r\n    // generated dimension name (like 'x', 'y').\r\n\r\n\r\n    var dimName = this._dimIdxToName.get(dimIdx);\r\n\r\n    if (dimName != null) {\r\n      return dimName;\r\n    }\r\n\r\n    var sourceDimDef = this._schema.getSourceDimension(dimIdx);\r\n\r\n    if (sourceDimDef) {\r\n      return sourceDimDef.name;\r\n    }\r\n  };\r\n  /**\r\n   * Get dimension index in data store. Return -1 if not found.\r\n   * Can be used to index value from getRawValue.\r\n   */\r\n\r\n\r\n  SeriesData.prototype.getDimensionIndex = function (dim) {\r\n    var dimIdx = this._recognizeDimIndex(dim);\r\n\r\n    if (dimIdx != null) {\r\n      return dimIdx;\r\n    }\r\n\r\n    if (dim == null) {\r\n      return -1;\r\n    }\r\n\r\n    var dimInfo = this._getDimInfo(dim);\r\n\r\n    return dimInfo ? dimInfo.storeDimIndex : this._dimOmitted ? this._schema.getSourceDimensionIndex(dim) : -1;\r\n  };\r\n  /**\r\n   * The meanings of the input parameter `dim`:\r\n   *\r\n   * + If dim is a number (e.g., `1`), it means the index of the dimension.\r\n   *   For example, `getDimension(0)` will return 'x' or 'lng' or 'radius'.\r\n   * + If dim is a number-like string (e.g., `\"1\"`):\r\n   *     + If there is the same concrete dim name defined in `series.dimensions` or `dataset.dimensions`,\r\n   *        it means that concrete name.\r\n   *     + If not, it will be converted to a number, which means the index of the dimension.\r\n   *        (why? because of the backward compatibility. We have been tolerating number-like string in\r\n   *        dimension setting, although now it seems that it is not a good idea.)\r\n   *     For example, `visualMap[i].dimension: \"1\"` is the same meaning as `visualMap[i].dimension: 1`,\r\n   *     if no dimension name is defined as `\"1\"`.\r\n   * + If dim is a not-number-like string, it means the concrete dim name.\r\n   *   For example, it can be be default name `\"x\"`, `\"y\"`, `\"z\"`, `\"lng\"`, `\"lat\"`, `\"angle\"`, `\"radius\"`,\r\n   *   or customized in `dimensions` property of option like `\"age\"`.\r\n   *\r\n   * @return recognized `DimensionIndex`. Otherwise return null/undefined (means that dim is `DimensionName`).\r\n   */\r\n\r\n\r\n  SeriesData.prototype._recognizeDimIndex = function (dim) {\r\n    if (zrUtil.isNumber(dim) // If being a number-like string but not being defined as a dimension name.\r\n    || dim != null && !isNaN(dim) && !this._getDimInfo(dim) && (!this._dimOmitted || this._schema.getSourceDimensionIndex(dim) < 0)) {\r\n      return +dim;\r\n    }\r\n  };\r\n\r\n  SeriesData.prototype._getStoreDimIndex = function (dim) {\r\n    var dimIdx = this.getDimensionIndex(dim);\r\n\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      if (dimIdx == null) {\r\n        throw new Error('Unknown dimension ' + dim);\r\n      }\r\n    }\r\n\r\n    return dimIdx;\r\n  };\r\n  /**\r\n   * Get type and calculation info of particular dimension\r\n   * @param dim\r\n   *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\r\n   *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\r\n   */\r\n\r\n\r\n  SeriesData.prototype.getDimensionInfo = function (dim) {\r\n    // Do not clone, because there may be categories in dimInfo.\r\n    return this._getDimInfo(this.getDimension(dim));\r\n  };\r\n\r\n  SeriesData.prototype._initGetDimensionInfo = function (needsHasOwn) {\r\n    var dimensionInfos = this._dimInfos;\r\n    this._getDimInfo = needsHasOwn ? function (dimName) {\r\n      return dimensionInfos.hasOwnProperty(dimName) ? dimensionInfos[dimName] : undefined;\r\n    } : function (dimName) {\r\n      return dimensionInfos[dimName];\r\n    };\r\n  };\r\n  /**\r\n   * concrete dimension name list on coord.\r\n   */\r\n\r\n\r\n  SeriesData.prototype.getDimensionsOnCoord = function () {\r\n    return this._dimSummary.dataDimsOnCoord.slice();\r\n  };\r\n\r\n  SeriesData.prototype.mapDimension = function (coordDim, idx) {\r\n    var dimensionsSummary = this._dimSummary;\r\n\r\n    if (idx == null) {\r\n      return dimensionsSummary.encodeFirstDimNotExtra[coordDim];\r\n    }\r\n\r\n    var dims = dimensionsSummary.encode[coordDim];\r\n    return dims ? dims[idx] : null;\r\n  };\r\n\r\n  SeriesData.prototype.mapDimensionsAll = function (coordDim) {\r\n    var dimensionsSummary = this._dimSummary;\r\n    var dims = dimensionsSummary.encode[coordDim];\r\n    return (dims || []).slice();\r\n  };\r\n\r\n  SeriesData.prototype.getStore = function () {\r\n    return this._store;\r\n  };\r\n  /**\r\n   * Initialize from data\r\n   * @param data source or data or data store.\r\n   * @param nameList The name of a datum is used on data diff and\r\n   *        default label/tooltip.\r\n   *        A name can be specified in encode.itemName,\r\n   *        or dataItem.name (only for series option data),\r\n   *        or provided in nameList from outside.\r\n   */\r\n\r\n\r\n  SeriesData.prototype.initData = function (data, nameList, dimValueGetter) {\r\n    var _this = this;\r\n\r\n    var store;\r\n\r\n    if (data instanceof DataStore) {\r\n      store = data;\r\n    }\r\n\r\n    if (!store) {\r\n      var dimensions = this.dimensions;\r\n      var provider = isSourceInstance(data) || zrUtil.isArrayLike(data) ? new DefaultDataProvider(data, dimensions.length) : data;\r\n      store = new DataStore();\r\n      var dimensionInfos = map(dimensions, function (dimName) {\r\n        return {\r\n          type: _this._dimInfos[dimName].type,\r\n          property: dimName\r\n        };\r\n      });\r\n      store.initData(provider, dimensionInfos, dimValueGetter);\r\n    }\r\n\r\n    this._store = store; // Reset\r\n\r\n    this._nameList = (nameList || []).slice();\r\n    this._idList = [];\r\n    this._nameRepeatCount = {};\r\n\r\n    this._doInit(0, store.count()); // Cache summary info for fast visit. See \"dimensionHelper\".\r\n    // Needs to be initialized after store is prepared.\r\n\r\n\r\n    this._dimSummary = summarizeDimensions(this, this._schema);\r\n    this.userOutput = this._dimSummary.userOutput;\r\n  };\r\n  /**\r\n   * Caution: Can be only called on raw data (before `this._indices` created).\r\n   */\r\n\r\n\r\n  SeriesData.prototype.appendData = function (data) {\r\n    var range = this._store.appendData(data);\r\n\r\n    this._doInit(range[0], range[1]);\r\n  };\r\n  /**\r\n   * Caution: Can be only called on raw data (before `this._indices` created).\r\n   * This method does not modify `rawData` (`dataProvider`), but only\r\n   * add values to store.\r\n   *\r\n   * The final count will be increased by `Math.max(values.length, names.length)`.\r\n   *\r\n   * @param values That is the SourceType: 'arrayRows', like\r\n   *        [\r\n   *            [12, 33, 44],\r\n   *            [NaN, 43, 1],\r\n   *            ['-', 'asdf', 0]\r\n   *        ]\r\n   *        Each item is exactly corresponding to a dimension.\r\n   */\r\n\r\n\r\n  SeriesData.prototype.appendValues = function (values, names) {\r\n    var _a = this._store.appendValues(values, names.length),\r\n        start = _a.start,\r\n        end = _a.end;\r\n\r\n    var shouldMakeIdFromName = this._shouldMakeIdFromName();\r\n\r\n    this._updateOrdinalMeta();\r\n\r\n    if (names) {\r\n      for (var idx = start; idx < end; idx++) {\r\n        var sourceIdx = idx - start;\r\n        this._nameList[idx] = names[sourceIdx];\r\n\r\n        if (shouldMakeIdFromName) {\r\n          makeIdFromName(this, idx);\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  SeriesData.prototype._updateOrdinalMeta = function () {\r\n    var store = this._store;\r\n    var dimensions = this.dimensions;\r\n\r\n    for (var i = 0; i < dimensions.length; i++) {\r\n      var dimInfo = this._dimInfos[dimensions[i]];\r\n\r\n      if (dimInfo.ordinalMeta) {\r\n        store.collectOrdinalMeta(dimInfo.storeDimIndex, dimInfo.ordinalMeta);\r\n      }\r\n    }\r\n  };\r\n\r\n  SeriesData.prototype._shouldMakeIdFromName = function () {\r\n    var provider = this._store.getProvider();\r\n\r\n    return this._idDimIdx == null && provider.getSource().sourceFormat !== SOURCE_FORMAT_TYPED_ARRAY && !provider.fillStorage;\r\n  };\r\n\r\n  SeriesData.prototype._doInit = function (start, end) {\r\n    if (start >= end) {\r\n      return;\r\n    }\r\n\r\n    var store = this._store;\r\n    var provider = store.getProvider();\r\n\r\n    this._updateOrdinalMeta();\r\n\r\n    var nameList = this._nameList;\r\n    var idList = this._idList;\r\n    var sourceFormat = provider.getSource().sourceFormat;\r\n    var isFormatOriginal = sourceFormat === SOURCE_FORMAT_ORIGINAL; // Each data item is value\r\n    // [1, 2]\r\n    // 2\r\n    // Bar chart, line chart which uses category axis\r\n    // only gives the 'y' value. 'x' value is the indices of category\r\n    // Use a tempValue to normalize the value to be a (x, y) value\r\n    // If dataItem is {name: ...} or {id: ...}, it has highest priority.\r\n    // This kind of ids and names are always stored `_nameList` and `_idList`.\r\n\r\n    if (isFormatOriginal && !provider.pure) {\r\n      var sharedDataItem = [];\r\n\r\n      for (var idx = start; idx < end; idx++) {\r\n        // NOTICE: Try not to write things into dataItem\r\n        var dataItem = provider.getItem(idx, sharedDataItem);\r\n\r\n        if (!this.hasItemOption && isDataItemOption(dataItem)) {\r\n          this.hasItemOption = true;\r\n        }\r\n\r\n        if (dataItem) {\r\n          var itemName = dataItem.name;\r\n\r\n          if (nameList[idx] == null && itemName != null) {\r\n            nameList[idx] = convertOptionIdName(itemName, null);\r\n          }\r\n\r\n          var itemId = dataItem.id;\r\n\r\n          if (idList[idx] == null && itemId != null) {\r\n            idList[idx] = convertOptionIdName(itemId, null);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (this._shouldMakeIdFromName()) {\r\n      for (var idx = start; idx < end; idx++) {\r\n        makeIdFromName(this, idx);\r\n      }\r\n    }\r\n\r\n    prepareInvertedIndex(this);\r\n  };\r\n  /**\r\n   * PENDING: In fact currently this function is only used to short-circuit\r\n   * the calling of `scale.unionExtentFromData` when data have been filtered by modules\r\n   * like \"dataZoom\". `scale.unionExtentFromData` is used to calculate data extent for series on\r\n   * an axis, but if a \"axis related data filter module\" is used, the extent of the axis have\r\n   * been fixed and no need to calling `scale.unionExtentFromData` actually.\r\n   * But if we add \"custom data filter\" in future, which is not \"axis related\", this method may\r\n   * be still needed.\r\n   *\r\n   * Optimize for the scenario that data is filtered by a given extent.\r\n   * Consider that if data amount is more than hundreds of thousand,\r\n   * extent calculation will cost more than 10ms and the cache will\r\n   * be erased because of the filtering.\r\n   */\r\n\r\n\r\n  SeriesData.prototype.getApproximateExtent = function (dim) {\r\n    return this._approximateExtent[dim] || this._store.getDataExtent(this._getStoreDimIndex(dim));\r\n  };\r\n  /**\r\n   * Calculate extent on a filtered data might be time consuming.\r\n   * Approximate extent is only used for: calculate extent of filtered data outside.\r\n   */\r\n\r\n\r\n  SeriesData.prototype.setApproximateExtent = function (extent, dim) {\r\n    dim = this.getDimension(dim);\r\n    this._approximateExtent[dim] = extent.slice();\r\n  };\r\n\r\n  SeriesData.prototype.getCalculationInfo = function (key) {\r\n    return this._calculationInfo[key];\r\n  };\r\n\r\n  SeriesData.prototype.setCalculationInfo = function (key, value) {\r\n    isObject(key) ? zrUtil.extend(this._calculationInfo, key) : this._calculationInfo[key] = value;\r\n  };\r\n  /**\r\n   * @return Never be null/undefined. `number` will be converted to string. Because:\r\n   * In most cases, name is used in display, where returning a string is more convenient.\r\n   * In other cases, name is used in query (see `indexOfName`), where we can keep the\r\n   * rule that name `2` equals to name `'2'`.\r\n   */\r\n\r\n\r\n  SeriesData.prototype.getName = function (idx) {\r\n    var rawIndex = this.getRawIndex(idx);\r\n    var name = this._nameList[rawIndex];\r\n\r\n    if (name == null && this._nameDimIdx != null) {\r\n      name = getIdNameFromStore(this, this._nameDimIdx, rawIndex);\r\n    }\r\n\r\n    if (name == null) {\r\n      name = '';\r\n    }\r\n\r\n    return name;\r\n  };\r\n\r\n  SeriesData.prototype._getCategory = function (dimIdx, idx) {\r\n    var ordinal = this._store.get(dimIdx, idx);\r\n\r\n    var ordinalMeta = this._store.getOrdinalMeta(dimIdx);\r\n\r\n    if (ordinalMeta) {\r\n      return ordinalMeta.categories[ordinal];\r\n    }\r\n\r\n    return ordinal;\r\n  };\r\n  /**\r\n   * @return Never null/undefined. `number` will be converted to string. Because:\r\n   * In all cases having encountered at present, id is used in making diff comparison, which\r\n   * are usually based on hash map. We can keep the rule that the internal id are always string\r\n   * (treat `2` is the same as `'2'`) to make the related logic simple.\r\n   */\r\n\r\n\r\n  SeriesData.prototype.getId = function (idx) {\r\n    return getId(this, this.getRawIndex(idx));\r\n  };\r\n\r\n  SeriesData.prototype.count = function () {\r\n    return this._store.count();\r\n  };\r\n  /**\r\n   * Get value. Return NaN if idx is out of range.\r\n   *\r\n   * @notice Should better to use `data.getStore().get(dimIndex, dataIdx)` instead.\r\n   */\r\n\r\n\r\n  SeriesData.prototype.get = function (dim, idx) {\r\n    var store = this._store;\r\n    var dimInfo = this._dimInfos[dim];\r\n\r\n    if (dimInfo) {\r\n      return store.get(dimInfo.storeDimIndex, idx);\r\n    }\r\n  };\r\n  /**\r\n   * @notice Should better to use `data.getStore().getByRawIndex(dimIndex, dataIdx)` instead.\r\n   */\r\n\r\n\r\n  SeriesData.prototype.getByRawIndex = function (dim, rawIdx) {\r\n    var store = this._store;\r\n    var dimInfo = this._dimInfos[dim];\r\n\r\n    if (dimInfo) {\r\n      return store.getByRawIndex(dimInfo.storeDimIndex, rawIdx);\r\n    }\r\n  };\r\n\r\n  SeriesData.prototype.getIndices = function () {\r\n    return this._store.getIndices();\r\n  };\r\n\r\n  SeriesData.prototype.getDataExtent = function (dim) {\r\n    return this._store.getDataExtent(this._getStoreDimIndex(dim));\r\n  };\r\n\r\n  SeriesData.prototype.getSum = function (dim) {\r\n    return this._store.getSum(this._getStoreDimIndex(dim));\r\n  };\r\n\r\n  SeriesData.prototype.getMedian = function (dim) {\r\n    return this._store.getMedian(this._getStoreDimIndex(dim));\r\n  };\r\n\r\n  SeriesData.prototype.getValues = function (dimensions, idx) {\r\n    var _this = this;\r\n\r\n    var store = this._store;\r\n    return zrUtil.isArray(dimensions) ? store.getValues(map(dimensions, function (dim) {\r\n      return _this._getStoreDimIndex(dim);\r\n    }), idx) : store.getValues(dimensions);\r\n  };\r\n  /**\r\n   * If value is NaN. Including '-'\r\n   * Only check the coord dimensions.\r\n   */\r\n\r\n\r\n  SeriesData.prototype.hasValue = function (idx) {\r\n    var dataDimIndicesOnCoord = this._dimSummary.dataDimIndicesOnCoord;\r\n\r\n    for (var i = 0, len = dataDimIndicesOnCoord.length; i < len; i++) {\r\n      // Ordinal type originally can be string or number.\r\n      // But when an ordinal type is used on coord, it can\r\n      // not be string but only number. So we can also use isNaN.\r\n      if (isNaN(this._store.get(dataDimIndicesOnCoord[i], idx))) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  };\r\n  /**\r\n   * Retrieve the index with given name\r\n   */\r\n\r\n\r\n  SeriesData.prototype.indexOfName = function (name) {\r\n    for (var i = 0, len = this._store.count(); i < len; i++) {\r\n      if (this.getName(i) === name) {\r\n        return i;\r\n      }\r\n    }\r\n\r\n    return -1;\r\n  };\r\n\r\n  SeriesData.prototype.getRawIndex = function (idx) {\r\n    return this._store.getRawIndex(idx);\r\n  };\r\n\r\n  SeriesData.prototype.indexOfRawIndex = function (rawIndex) {\r\n    return this._store.indexOfRawIndex(rawIndex);\r\n  };\r\n  /**\r\n   * Only support the dimension which inverted index created.\r\n   * Do not support other cases until required.\r\n   * @param dim concrete dim\r\n   * @param value ordinal index\r\n   * @return rawIndex\r\n   */\r\n\r\n\r\n  SeriesData.prototype.rawIndexOf = function (dim, value) {\r\n    var invertedIndices = dim && this._invertedIndicesMap[dim];\r\n\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      if (!invertedIndices) {\r\n        throw new Error('Do not supported yet');\r\n      }\r\n    }\r\n\r\n    var rawIndex = invertedIndices[value];\r\n\r\n    if (rawIndex == null || isNaN(rawIndex)) {\r\n      return INDEX_NOT_FOUND;\r\n    }\r\n\r\n    return rawIndex;\r\n  };\r\n  /**\r\n   * Retrieve the index of nearest value\r\n   * @param dim\r\n   * @param value\r\n   * @param [maxDistance=Infinity]\r\n   * @return If and only if multiple indices has\r\n   *         the same value, they are put to the result.\r\n   */\r\n\r\n\r\n  SeriesData.prototype.indicesOfNearest = function (dim, value, maxDistance) {\r\n    return this._store.indicesOfNearest(this._getStoreDimIndex(dim), value, maxDistance);\r\n  };\r\n\r\n  SeriesData.prototype.each = function (dims, cb, ctx) {\r\n    'use strict';\r\n\r\n    if (zrUtil.isFunction(dims)) {\r\n      ctx = cb;\r\n      cb = dims;\r\n      dims = [];\r\n    } // ctxCompat just for compat echarts3\r\n\r\n\r\n    var fCtx = ctx || this;\r\n    var dimIndices = map(normalizeDimensions(dims), this._getStoreDimIndex, this);\r\n\r\n    this._store.each(dimIndices, fCtx ? zrUtil.bind(cb, fCtx) : cb);\r\n  };\r\n\r\n  SeriesData.prototype.filterSelf = function (dims, cb, ctx) {\r\n    'use strict';\r\n\r\n    if (zrUtil.isFunction(dims)) {\r\n      ctx = cb;\r\n      cb = dims;\r\n      dims = [];\r\n    } // ctxCompat just for compat echarts3\r\n\r\n\r\n    var fCtx = ctx || this;\r\n    var dimIndices = map(normalizeDimensions(dims), this._getStoreDimIndex, this);\r\n    this._store = this._store.filter(dimIndices, fCtx ? zrUtil.bind(cb, fCtx) : cb);\r\n    return this;\r\n  };\r\n  /**\r\n   * Select data in range. (For optimization of filter)\r\n   * (Manually inline code, support 5 million data filtering in data zoom.)\r\n   */\r\n\r\n\r\n  SeriesData.prototype.selectRange = function (range) {\r\n    'use strict';\r\n\r\n    var _this = this;\r\n\r\n    var innerRange = {};\r\n    var dims = zrUtil.keys(range);\r\n    var dimIndices = [];\r\n    zrUtil.each(dims, function (dim) {\r\n      var dimIdx = _this._getStoreDimIndex(dim);\r\n\r\n      innerRange[dimIdx] = range[dim];\r\n      dimIndices.push(dimIdx);\r\n    });\r\n    this._store = this._store.selectRange(innerRange);\r\n    return this;\r\n  };\r\n  /* eslint-enable max-len */\r\n\r\n\r\n  SeriesData.prototype.mapArray = function (dims, cb, ctx) {\r\n    'use strict';\r\n\r\n    if (zrUtil.isFunction(dims)) {\r\n      ctx = cb;\r\n      cb = dims;\r\n      dims = [];\r\n    } // ctxCompat just for compat echarts3\r\n\r\n\r\n    ctx = ctx || this;\r\n    var result = [];\r\n    this.each(dims, function () {\r\n      result.push(cb && cb.apply(this, arguments));\r\n    }, ctx);\r\n    return result;\r\n  };\r\n\r\n  SeriesData.prototype.map = function (dims, cb, ctx, ctxCompat) {\r\n    'use strict'; // ctxCompat just for compat echarts3\r\n\r\n    var fCtx = ctx || ctxCompat || this;\r\n    var dimIndices = map(normalizeDimensions(dims), this._getStoreDimIndex, this);\r\n    var list = cloneListForMapAndSample(this);\r\n    list._store = this._store.map(dimIndices, fCtx ? zrUtil.bind(cb, fCtx) : cb);\r\n    return list;\r\n  };\r\n\r\n  SeriesData.prototype.modify = function (dims, cb, ctx, ctxCompat) {\r\n    var _this = this; // ctxCompat just for compat echarts3\r\n\r\n\r\n    var fCtx = ctx || ctxCompat || this;\r\n\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      zrUtil.each(normalizeDimensions(dims), function (dim) {\r\n        var dimInfo = _this.getDimensionInfo(dim);\r\n\r\n        if (!dimInfo.isCalculationCoord) {\r\n          console.error('Danger: only stack dimension can be modified');\r\n        }\r\n      });\r\n    }\r\n\r\n    var dimIndices = map(normalizeDimensions(dims), this._getStoreDimIndex, this); // If do shallow clone here, if there are too many stacked series,\r\n    // it still cost lots of memory, because `_store.dimensions` are not shared.\r\n    // We should consider there probably be shallow clone happen in each series\r\n    // in consequent filter/map.\r\n\r\n    this._store.modify(dimIndices, fCtx ? zrUtil.bind(cb, fCtx) : cb);\r\n  };\r\n  /**\r\n   * Large data down sampling on given dimension\r\n   * @param sampleIndex Sample index for name and id\r\n   */\r\n\r\n\r\n  SeriesData.prototype.downSample = function (dimension, rate, sampleValue, sampleIndex) {\r\n    var list = cloneListForMapAndSample(this);\r\n    list._store = this._store.downSample(this._getStoreDimIndex(dimension), rate, sampleValue, sampleIndex);\r\n    return list;\r\n  };\r\n  /**\r\n   * Large data down sampling using largest-triangle-three-buckets\r\n   * @param {string} valueDimension\r\n   * @param {number} targetCount\r\n   */\r\n\r\n\r\n  SeriesData.prototype.lttbDownSample = function (valueDimension, rate) {\r\n    var list = cloneListForMapAndSample(this);\r\n    list._store = this._store.lttbDownSample(this._getStoreDimIndex(valueDimension), rate);\r\n    return list;\r\n  };\r\n\r\n  SeriesData.prototype.getRawDataItem = function (idx) {\r\n    return this._store.getRawDataItem(idx);\r\n  };\r\n  /**\r\n   * Get model of one data item.\r\n   */\r\n  // TODO: Type of data item\r\n\r\n\r\n  SeriesData.prototype.getItemModel = function (idx) {\r\n    var hostModel = this.hostModel;\r\n    var dataItem = this.getRawDataItem(idx);\r\n    return new Model(dataItem, hostModel, hostModel && hostModel.ecModel);\r\n  };\r\n  /**\r\n   * Create a data differ\r\n   */\r\n\r\n\r\n  SeriesData.prototype.diff = function (otherList) {\r\n    var thisList = this;\r\n    return new DataDiffer(otherList ? otherList.getStore().getIndices() : [], this.getStore().getIndices(), function (idx) {\r\n      return getId(otherList, idx);\r\n    }, function (idx) {\r\n      return getId(thisList, idx);\r\n    });\r\n  };\r\n  /**\r\n   * Get visual property.\r\n   */\r\n\r\n\r\n  SeriesData.prototype.getVisual = function (key) {\r\n    var visual = this._visual;\r\n    return visual && visual[key];\r\n  };\r\n\r\n  SeriesData.prototype.setVisual = function (kvObj, val) {\r\n    this._visual = this._visual || {};\r\n\r\n    if (isObject(kvObj)) {\r\n      zrUtil.extend(this._visual, kvObj);\r\n    } else {\r\n      this._visual[kvObj] = val;\r\n    }\r\n  };\r\n  /**\r\n   * Get visual property of single data item\r\n   */\r\n  // eslint-disable-next-line\r\n\r\n\r\n  SeriesData.prototype.getItemVisual = function (idx, key) {\r\n    var itemVisual = this._itemVisuals[idx];\r\n    var val = itemVisual && itemVisual[key];\r\n\r\n    if (val == null) {\r\n      // Use global visual property\r\n      return this.getVisual(key);\r\n    }\r\n\r\n    return val;\r\n  };\r\n  /**\r\n   * If exists visual property of single data item\r\n   */\r\n\r\n\r\n  SeriesData.prototype.hasItemVisual = function () {\r\n    return this._itemVisuals.length > 0;\r\n  };\r\n  /**\r\n   * Make sure itemVisual property is unique\r\n   */\r\n  // TODO: use key to save visual to reduce memory.\r\n\r\n\r\n  SeriesData.prototype.ensureUniqueItemVisual = function (idx, key) {\r\n    var itemVisuals = this._itemVisuals;\r\n    var itemVisual = itemVisuals[idx];\r\n\r\n    if (!itemVisual) {\r\n      itemVisual = itemVisuals[idx] = {};\r\n    }\r\n\r\n    var val = itemVisual[key];\r\n\r\n    if (val == null) {\r\n      val = this.getVisual(key); // TODO Performance?\r\n\r\n      if (zrUtil.isArray(val)) {\r\n        val = val.slice();\r\n      } else if (isObject(val)) {\r\n        val = zrUtil.extend({}, val);\r\n      }\r\n\r\n      itemVisual[key] = val;\r\n    }\r\n\r\n    return val;\r\n  }; // eslint-disable-next-line\r\n\r\n\r\n  SeriesData.prototype.setItemVisual = function (idx, key, value) {\r\n    var itemVisual = this._itemVisuals[idx] || {};\r\n    this._itemVisuals[idx] = itemVisual;\r\n\r\n    if (isObject(key)) {\r\n      zrUtil.extend(itemVisual, key);\r\n    } else {\r\n      itemVisual[key] = value;\r\n    }\r\n  };\r\n  /**\r\n   * Clear itemVisuals and list visual.\r\n   */\r\n\r\n\r\n  SeriesData.prototype.clearAllVisual = function () {\r\n    this._visual = {};\r\n    this._itemVisuals = [];\r\n  };\r\n\r\n  SeriesData.prototype.setLayout = function (key, val) {\r\n    isObject(key) ? zrUtil.extend(this._layout, key) : this._layout[key] = val;\r\n  };\r\n  /**\r\n   * Get layout property.\r\n   */\r\n\r\n\r\n  SeriesData.prototype.getLayout = function (key) {\r\n    return this._layout[key];\r\n  };\r\n  /**\r\n   * Get layout of single data item\r\n   */\r\n\r\n\r\n  SeriesData.prototype.getItemLayout = function (idx) {\r\n    return this._itemLayouts[idx];\r\n  };\r\n  /**\r\n   * Set layout of single data item\r\n   */\r\n\r\n\r\n  SeriesData.prototype.setItemLayout = function (idx, layout, merge) {\r\n    this._itemLayouts[idx] = merge ? zrUtil.extend(this._itemLayouts[idx] || {}, layout) : layout;\r\n  };\r\n  /**\r\n   * Clear all layout of single data item\r\n   */\r\n\r\n\r\n  SeriesData.prototype.clearItemLayouts = function () {\r\n    this._itemLayouts.length = 0;\r\n  };\r\n  /**\r\n   * Set graphic element relative to data. It can be set as null\r\n   */\r\n\r\n\r\n  SeriesData.prototype.setItemGraphicEl = function (idx, el) {\r\n    var seriesIndex = this.hostModel && this.hostModel.seriesIndex;\r\n    setCommonECData(seriesIndex, this.dataType, idx, el);\r\n    this._graphicEls[idx] = el;\r\n  };\r\n\r\n  SeriesData.prototype.getItemGraphicEl = function (idx) {\r\n    return this._graphicEls[idx];\r\n  };\r\n\r\n  SeriesData.prototype.eachItemGraphicEl = function (cb, context) {\r\n    zrUtil.each(this._graphicEls, function (el, idx) {\r\n      if (el) {\r\n        cb && cb.call(context, el, idx);\r\n      }\r\n    });\r\n  };\r\n  /**\r\n   * Shallow clone a new list except visual and layout properties, and graph elements.\r\n   * New list only change the indices.\r\n   */\r\n\r\n\r\n  SeriesData.prototype.cloneShallow = function (list) {\r\n    if (!list) {\r\n      list = new SeriesData(this._schema ? this._schema : map(this.dimensions, this._getDimInfo, this), this.hostModel);\r\n    }\r\n\r\n    transferProperties(list, this);\r\n    list._store = this._store;\r\n    return list;\r\n  };\r\n  /**\r\n   * Wrap some method to add more feature\r\n   */\r\n\r\n\r\n  SeriesData.prototype.wrapMethod = function (methodName, injectFunction) {\r\n    var originalMethod = this[methodName];\r\n\r\n    if (!zrUtil.isFunction(originalMethod)) {\r\n      return;\r\n    }\r\n\r\n    this.__wrappedMethods = this.__wrappedMethods || [];\r\n\r\n    this.__wrappedMethods.push(methodName);\r\n\r\n    this[methodName] = function () {\r\n      var res = originalMethod.apply(this, arguments);\r\n      return injectFunction.apply(this, [res].concat(zrUtil.slice(arguments)));\r\n    };\r\n  }; // ----------------------------------------------------------\r\n  // A work around for internal method visiting private member.\r\n  // ----------------------------------------------------------\r\n\r\n\r\n  SeriesData.internalField = function () {\r\n    prepareInvertedIndex = function (data) {\r\n      var invertedIndicesMap = data._invertedIndicesMap;\r\n      zrUtil.each(invertedIndicesMap, function (invertedIndices, dim) {\r\n        var dimInfo = data._dimInfos[dim]; // Currently, only dimensions that has ordinalMeta can create inverted indices.\r\n\r\n        var ordinalMeta = dimInfo.ordinalMeta;\r\n        var store = data._store;\r\n\r\n        if (ordinalMeta) {\r\n          invertedIndices = invertedIndicesMap[dim] = new CtorInt32Array(ordinalMeta.categories.length); // The default value of TypedArray is 0. To avoid miss\r\n          // mapping to 0, we should set it as INDEX_NOT_FOUND.\r\n\r\n          for (var i = 0; i < invertedIndices.length; i++) {\r\n            invertedIndices[i] = INDEX_NOT_FOUND;\r\n          }\r\n\r\n          for (var i = 0; i < store.count(); i++) {\r\n            // Only support the case that all values are distinct.\r\n            invertedIndices[store.get(dimInfo.storeDimIndex, i)] = i;\r\n          }\r\n        }\r\n      });\r\n    };\r\n\r\n    getIdNameFromStore = function (data, dimIdx, idx) {\r\n      return convertOptionIdName(data._getCategory(dimIdx, idx), null);\r\n    };\r\n    /**\r\n     * @see the comment of `List['getId']`.\r\n     */\r\n\r\n\r\n    getId = function (data, rawIndex) {\r\n      var id = data._idList[rawIndex];\r\n\r\n      if (id == null && data._idDimIdx != null) {\r\n        id = getIdNameFromStore(data, data._idDimIdx, rawIndex);\r\n      }\r\n\r\n      if (id == null) {\r\n        id = ID_PREFIX + rawIndex;\r\n      }\r\n\r\n      return id;\r\n    };\r\n\r\n    normalizeDimensions = function (dimensions) {\r\n      if (!zrUtil.isArray(dimensions)) {\r\n        dimensions = dimensions != null ? [dimensions] : [];\r\n      }\r\n\r\n      return dimensions;\r\n    };\r\n    /**\r\n     * Data in excludeDimensions is copied, otherwise transferred.\r\n     */\r\n\r\n\r\n    cloneListForMapAndSample = function (original) {\r\n      var list = new SeriesData(original._schema ? original._schema : map(original.dimensions, original._getDimInfo, original), original.hostModel); // FIXME If needs stackedOn, value may already been stacked\r\n\r\n      transferProperties(list, original);\r\n      return list;\r\n    };\r\n\r\n    transferProperties = function (target, source) {\r\n      zrUtil.each(TRANSFERABLE_PROPERTIES.concat(source.__wrappedMethods || []), function (propName) {\r\n        if (source.hasOwnProperty(propName)) {\r\n          target[propName] = source[propName];\r\n        }\r\n      });\r\n      target.__wrappedMethods = source.__wrappedMethods;\r\n      zrUtil.each(CLONE_PROPERTIES, function (propName) {\r\n        target[propName] = zrUtil.clone(source[propName]);\r\n      });\r\n      target._calculationInfo = zrUtil.extend({}, source._calculationInfo);\r\n    };\r\n\r\n    makeIdFromName = function (data, idx) {\r\n      var nameList = data._nameList;\r\n      var idList = data._idList;\r\n      var nameDimIdx = data._nameDimIdx;\r\n      var idDimIdx = data._idDimIdx;\r\n      var name = nameList[idx];\r\n      var id = idList[idx];\r\n\r\n      if (name == null && nameDimIdx != null) {\r\n        nameList[idx] = name = getIdNameFromStore(data, nameDimIdx, idx);\r\n      }\r\n\r\n      if (id == null && idDimIdx != null) {\r\n        idList[idx] = id = getIdNameFromStore(data, idDimIdx, idx);\r\n      }\r\n\r\n      if (id == null && name != null) {\r\n        var nameRepeatCount = data._nameRepeatCount;\r\n        var nmCnt = nameRepeatCount[name] = (nameRepeatCount[name] || 0) + 1;\r\n        id = name;\r\n\r\n        if (nmCnt > 1) {\r\n          id += '__ec__' + nmCnt;\r\n        }\r\n\r\n        idList[idx] = id;\r\n      }\r\n    };\r\n  }();\r\n\r\n  return SeriesData;\r\n}();\r\n\r\nexport default SeriesData;"],
  "mappings": "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",
  "names": ["DimensionUserOuput", "SeriesDimensionDefine", "isObject", "map", "SeriesData"]
}
