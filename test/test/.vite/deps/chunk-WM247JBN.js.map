{
  "version": 3,
  "sources": ["../../node_modules/zrender/lib/contain/polygon.js", "../../node_modules/echarts/lib/coord/geo/Region.js", "../../node_modules/echarts/lib/coord/geo/parseGeoJson.js", "../../node_modules/echarts/lib/coord/axisTickLabelBuilder.js", "../../node_modules/echarts/lib/coord/Axis.js", "../../node_modules/echarts/lib/coord/axisModelCommonMixin.js"],
  "sourcesContent": ["import windingLine from './windingLine.js';\r\nvar EPSILON = 1e-8;\r\nfunction isAroundEqual(a, b) {\r\n    return Math.abs(a - b) < EPSILON;\r\n}\r\nexport function contain(points, x, y) {\r\n    var w = 0;\r\n    var p = points[0];\r\n    if (!p) {\r\n        return false;\r\n    }\r\n    for (var i = 1; i < points.length; i++) {\r\n        var p2 = points[i];\r\n        w += windingLine(p[0], p[1], p2[0], p2[1], x, y);\r\n        p = p2;\r\n    }\r\n    var p0 = points[0];\r\n    if (!isAroundEqual(p[0], p0[0]) || !isAroundEqual(p[1], p0[1])) {\r\n        w += windingLine(p[0], p[1], p0[0], p0[1], x, y);\r\n    }\r\n    return w !== 0;\r\n}\r\n", "\r\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\r\n\r\n\r\n/**\r\n * AUTO-GENERATED FILE. DO NOT MODIFY.\r\n */\r\n\r\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\r\nimport { __extends } from \"tslib\";\r\nimport BoundingRect from 'zrender/lib/core/BoundingRect.js';\r\nimport * as vec2 from 'zrender/lib/core/vector.js';\r\nimport * as polygonContain from 'zrender/lib/contain/polygon.js';\r\nimport * as matrix from 'zrender/lib/core/matrix.js';\r\nimport { each } from 'zrender/lib/core/util.js';\r\nvar TMP_TRANSFORM = [];\r\n\r\nfunction transformPoints(points, transform) {\r\n  for (var p = 0; p < points.length; p++) {\r\n    vec2.applyTransform(points[p], points[p], transform);\r\n  }\r\n}\r\n\r\nfunction updateBBoxFromPoints(points, min, max, projection) {\r\n  for (var i = 0; i < points.length; i++) {\r\n    var p = points[i];\r\n\r\n    if (projection) {\r\n      // projection may return null point.\r\n      p = projection.project(p);\r\n    }\r\n\r\n    if (p && isFinite(p[0]) && isFinite(p[1])) {\r\n      vec2.min(min, min, p);\r\n      vec2.max(max, max, p);\r\n    }\r\n  }\r\n}\r\n\r\nfunction centroid(points) {\r\n  var signedArea = 0;\r\n  var cx = 0;\r\n  var cy = 0;\r\n  var len = points.length;\r\n  var x0 = points[len - 1][0];\r\n  var y0 = points[len - 1][1]; // Polygon should been closed.\r\n\r\n  for (var i = 0; i < len; i++) {\r\n    var x1 = points[i][0];\r\n    var y1 = points[i][1];\r\n    var a = x0 * y1 - x1 * y0;\r\n    signedArea += a;\r\n    cx += (x0 + x1) * a;\r\n    cy += (y0 + y1) * a;\r\n    x0 = x1;\r\n    y0 = y1;\r\n  }\r\n\r\n  return signedArea ? [cx / signedArea / 3, cy / signedArea / 3, signedArea] : [points[0][0] || 0, points[0][1] || 0];\r\n}\r\n\r\nvar Region =\r\n/** @class */\r\nfunction () {\r\n  function Region(name) {\r\n    this.name = name;\r\n  }\r\n\r\n  Region.prototype.setCenter = function (center) {\r\n    this._center = center;\r\n  };\r\n  /**\r\n   * Get center point in data unit. That is,\r\n   * for GeoJSONRegion, the unit is lat/lng,\r\n   * for GeoSVGRegion, the unit is SVG local coord.\r\n   */\r\n\r\n\r\n  Region.prototype.getCenter = function () {\r\n    var center = this._center;\r\n\r\n    if (!center) {\r\n      // In most cases there are no need to calculate this center.\r\n      // So calculate only when called.\r\n      center = this._center = this.calcCenter();\r\n    }\r\n\r\n    return center;\r\n  };\r\n\r\n  return Region;\r\n}();\r\n\r\nexport { Region };\r\n\r\nvar GeoJSONPolygonGeometry =\r\n/** @class */\r\nfunction () {\r\n  function GeoJSONPolygonGeometry(exterior, interiors) {\r\n    this.type = 'polygon';\r\n    this.exterior = exterior;\r\n    this.interiors = interiors;\r\n  }\r\n\r\n  return GeoJSONPolygonGeometry;\r\n}();\r\n\r\nexport { GeoJSONPolygonGeometry };\r\n\r\nvar GeoJSONLineStringGeometry =\r\n/** @class */\r\nfunction () {\r\n  function GeoJSONLineStringGeometry(points) {\r\n    this.type = 'linestring';\r\n    this.points = points;\r\n  }\r\n\r\n  return GeoJSONLineStringGeometry;\r\n}();\r\n\r\nexport { GeoJSONLineStringGeometry };\r\n\r\nvar GeoJSONRegion =\r\n/** @class */\r\nfunction (_super) {\r\n  __extends(GeoJSONRegion, _super);\r\n\r\n  function GeoJSONRegion(name, geometries, cp) {\r\n    var _this = _super.call(this, name) || this;\r\n\r\n    _this.type = 'geoJSON';\r\n    _this.geometries = geometries;\r\n    _this._center = cp && [cp[0], cp[1]];\r\n    return _this;\r\n  }\r\n\r\n  GeoJSONRegion.prototype.calcCenter = function () {\r\n    var geometries = this.geometries;\r\n    var largestGeo;\r\n    var largestGeoSize = 0;\r\n\r\n    for (var i = 0; i < geometries.length; i++) {\r\n      var geo = geometries[i];\r\n      var exterior = geo.exterior; // Simple trick to use points count instead of polygon area as region size.\r\n      // Ignore linestring\r\n\r\n      var size = exterior && exterior.length;\r\n\r\n      if (size > largestGeoSize) {\r\n        largestGeo = geo;\r\n        largestGeoSize = size;\r\n      }\r\n    }\r\n\r\n    if (largestGeo) {\r\n      return centroid(largestGeo.exterior);\r\n    } // from bounding rect by default.\r\n\r\n\r\n    var rect = this.getBoundingRect();\r\n    return [rect.x + rect.width / 2, rect.y + rect.height / 2];\r\n  };\r\n\r\n  GeoJSONRegion.prototype.getBoundingRect = function (projection) {\r\n    var rect = this._rect; // Always recalculate if using projection.\r\n\r\n    if (rect && !projection) {\r\n      return rect;\r\n    }\r\n\r\n    var min = [Infinity, Infinity];\r\n    var max = [-Infinity, -Infinity];\r\n    var geometries = this.geometries;\r\n    each(geometries, function (geo) {\r\n      if (geo.type === 'polygon') {\r\n        // Doesn't consider hole\r\n        updateBBoxFromPoints(geo.exterior, min, max, projection);\r\n      } else {\r\n        each(geo.points, function (points) {\r\n          updateBBoxFromPoints(points, min, max, projection);\r\n        });\r\n      }\r\n    }); // Normalie invalid bounding.\r\n\r\n    if (!(isFinite(min[0]) && isFinite(min[1]) && isFinite(max[0]) && isFinite(max[1]))) {\r\n      min[0] = min[1] = max[0] = max[1] = 0;\r\n    }\r\n\r\n    rect = new BoundingRect(min[0], min[1], max[0] - min[0], max[1] - min[1]);\r\n\r\n    if (!projection) {\r\n      this._rect = rect;\r\n    }\r\n\r\n    return rect;\r\n  };\r\n\r\n  GeoJSONRegion.prototype.contain = function (coord) {\r\n    var rect = this.getBoundingRect();\r\n    var geometries = this.geometries;\r\n\r\n    if (!rect.contain(coord[0], coord[1])) {\r\n      return false;\r\n    }\r\n\r\n    loopGeo: for (var i = 0, len = geometries.length; i < len; i++) {\r\n      var geo = geometries[i]; // Only support polygon.\r\n\r\n      if (geo.type !== 'polygon') {\r\n        continue;\r\n      }\r\n\r\n      var exterior = geo.exterior;\r\n      var interiors = geo.interiors;\r\n\r\n      if (polygonContain.contain(exterior, coord[0], coord[1])) {\r\n        // Not in the region if point is in the hole.\r\n        for (var k = 0; k < (interiors ? interiors.length : 0); k++) {\r\n          if (polygonContain.contain(interiors[k], coord[0], coord[1])) {\r\n            continue loopGeo;\r\n          }\r\n        }\r\n\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  };\r\n  /**\r\n   * Transform the raw coords to target bounding.\r\n   * @param x\r\n   * @param y\r\n   * @param width\r\n   * @param height\r\n   */\r\n\r\n\r\n  GeoJSONRegion.prototype.transformTo = function (x, y, width, height) {\r\n    var rect = this.getBoundingRect();\r\n    var aspect = rect.width / rect.height;\r\n\r\n    if (!width) {\r\n      width = aspect * height;\r\n    } else if (!height) {\r\n      height = width / aspect;\r\n    }\r\n\r\n    var target = new BoundingRect(x, y, width, height);\r\n    var transform = rect.calculateTransform(target);\r\n    var geometries = this.geometries;\r\n\r\n    for (var i = 0; i < geometries.length; i++) {\r\n      var geo = geometries[i];\r\n\r\n      if (geo.type === 'polygon') {\r\n        transformPoints(geo.exterior, transform);\r\n        each(geo.interiors, function (interior) {\r\n          transformPoints(interior, transform);\r\n        });\r\n      } else {\r\n        each(geo.points, function (points) {\r\n          transformPoints(points, transform);\r\n        });\r\n      }\r\n    }\r\n\r\n    rect = this._rect;\r\n    rect.copy(target); // Update center\r\n\r\n    this._center = [rect.x + rect.width / 2, rect.y + rect.height / 2];\r\n  };\r\n\r\n  GeoJSONRegion.prototype.cloneShallow = function (name) {\r\n    name == null && (name = this.name);\r\n    var newRegion = new GeoJSONRegion(name, this.geometries, this._center);\r\n    newRegion._rect = this._rect;\r\n    newRegion.transformTo = null; // Simply avoid to be called.\r\n\r\n    return newRegion;\r\n  };\r\n\r\n  return GeoJSONRegion;\r\n}(Region);\r\n\r\nexport { GeoJSONRegion };\r\n\r\nvar GeoSVGRegion =\r\n/** @class */\r\nfunction (_super) {\r\n  __extends(GeoSVGRegion, _super);\r\n\r\n  function GeoSVGRegion(name, elOnlyForCalculate) {\r\n    var _this = _super.call(this, name) || this;\r\n\r\n    _this.type = 'geoSVG';\r\n    _this._elOnlyForCalculate = elOnlyForCalculate;\r\n    return _this;\r\n  }\r\n\r\n  GeoSVGRegion.prototype.calcCenter = function () {\r\n    var el = this._elOnlyForCalculate;\r\n    var rect = el.getBoundingRect();\r\n    var center = [rect.x + rect.width / 2, rect.y + rect.height / 2];\r\n    var mat = matrix.identity(TMP_TRANSFORM);\r\n    var target = el;\r\n\r\n    while (target && !target.isGeoSVGGraphicRoot) {\r\n      matrix.mul(mat, target.getLocalTransform(), mat);\r\n      target = target.parent;\r\n    }\r\n\r\n    matrix.invert(mat, mat);\r\n    vec2.applyTransform(center, center, mat);\r\n    return center;\r\n  };\r\n\r\n  return GeoSVGRegion;\r\n}(Region);\r\n\r\nexport { GeoSVGRegion };", "\r\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\r\n\r\n\r\n/**\r\n * AUTO-GENERATED FILE. DO NOT MODIFY.\r\n */\r\n\r\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\r\n\r\n/**\r\n * Parse and decode geo json\r\n */\r\nimport * as zrUtil from 'zrender/lib/core/util.js';\r\nimport { GeoJSONLineStringGeometry, GeoJSONPolygonGeometry, GeoJSONRegion } from './Region.js';\r\n\r\nfunction decode(json) {\r\n  if (!json.UTF8Encoding) {\r\n    return json;\r\n  }\r\n\r\n  var jsonCompressed = json;\r\n  var encodeScale = jsonCompressed.UTF8Scale;\r\n\r\n  if (encodeScale == null) {\r\n    encodeScale = 1024;\r\n  }\r\n\r\n  var features = jsonCompressed.features;\r\n  zrUtil.each(features, function (feature) {\r\n    var geometry = feature.geometry;\r\n    var encodeOffsets = geometry.encodeOffsets;\r\n    var coordinates = geometry.coordinates; // Geometry may be appeded manually in the script after json loaded.\r\n    // In this case this geometry is usually not encoded.\r\n\r\n    if (!encodeOffsets) {\r\n      return;\r\n    }\r\n\r\n    switch (geometry.type) {\r\n      case 'LineString':\r\n        geometry.coordinates = decodeRing(coordinates, encodeOffsets, encodeScale);\r\n        break;\r\n\r\n      case 'Polygon':\r\n        decodeRings(coordinates, encodeOffsets, encodeScale);\r\n        break;\r\n\r\n      case 'MultiLineString':\r\n        decodeRings(coordinates, encodeOffsets, encodeScale);\r\n        break;\r\n\r\n      case 'MultiPolygon':\r\n        zrUtil.each(coordinates, function (rings, idx) {\r\n          return decodeRings(rings, encodeOffsets[idx], encodeScale);\r\n        });\r\n    }\r\n  }); // Has been decoded\r\n\r\n  jsonCompressed.UTF8Encoding = false;\r\n  return jsonCompressed;\r\n}\r\n\r\nfunction decodeRings(rings, encodeOffsets, encodeScale) {\r\n  for (var c = 0; c < rings.length; c++) {\r\n    rings[c] = decodeRing(rings[c], encodeOffsets[c], encodeScale);\r\n  }\r\n}\r\n\r\nfunction decodeRing(coordinate, encodeOffsets, encodeScale) {\r\n  var result = [];\r\n  var prevX = encodeOffsets[0];\r\n  var prevY = encodeOffsets[1];\r\n\r\n  for (var i = 0; i < coordinate.length; i += 2) {\r\n    var x = coordinate.charCodeAt(i) - 64;\r\n    var y = coordinate.charCodeAt(i + 1) - 64; // ZigZag decoding\r\n\r\n    x = x >> 1 ^ -(x & 1);\r\n    y = y >> 1 ^ -(y & 1); // Delta deocding\r\n\r\n    x += prevX;\r\n    y += prevY;\r\n    prevX = x;\r\n    prevY = y; // Dequantize\r\n\r\n    result.push([x / encodeScale, y / encodeScale]);\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nexport default function parseGeoJSON(geoJson, nameProperty) {\r\n  geoJson = decode(geoJson);\r\n  return zrUtil.map(zrUtil.filter(geoJson.features, function (featureObj) {\r\n    // Output of mapshaper may have geometry null\r\n    return featureObj.geometry && featureObj.properties && featureObj.geometry.coordinates.length > 0;\r\n  }), function (featureObj) {\r\n    var properties = featureObj.properties;\r\n    var geo = featureObj.geometry;\r\n    var geometries = [];\r\n\r\n    switch (geo.type) {\r\n      case 'Polygon':\r\n        var coordinates = geo.coordinates; // According to the GeoJSON specification.\r\n        // First must be exterior, and the rest are all interior(holes).\r\n\r\n        geometries.push(new GeoJSONPolygonGeometry(coordinates[0], coordinates.slice(1)));\r\n        break;\r\n\r\n      case 'MultiPolygon':\r\n        zrUtil.each(geo.coordinates, function (item) {\r\n          if (item[0]) {\r\n            geometries.push(new GeoJSONPolygonGeometry(item[0], item.slice(1)));\r\n          }\r\n        });\r\n        break;\r\n\r\n      case 'LineString':\r\n        geometries.push(new GeoJSONLineStringGeometry([geo.coordinates]));\r\n        break;\r\n\r\n      case 'MultiLineString':\r\n        geometries.push(new GeoJSONLineStringGeometry(geo.coordinates));\r\n    }\r\n\r\n    var region = new GeoJSONRegion(properties[nameProperty || 'name'], geometries, properties.cp);\r\n    region.properties = properties;\r\n    return region;\r\n  });\r\n}", "\r\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\r\n\r\n\r\n/**\r\n * AUTO-GENERATED FILE. DO NOT MODIFY.\r\n */\r\n\r\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\r\nimport * as zrUtil from 'zrender/lib/core/util.js';\r\nimport * as textContain from 'zrender/lib/contain/text.js';\r\nimport { makeInner } from '../util/model.js';\r\nimport { makeLabelFormatter, getOptionCategoryInterval, shouldShowAllLabels } from './axisHelper.js';\r\nvar inner = makeInner();\r\nexport function createAxisLabels(axis) {\r\n  // Only ordinal scale support tick interval\r\n  return axis.type === 'category' ? makeCategoryLabels(axis) : makeRealNumberLabels(axis);\r\n}\r\n/**\r\n * @param {module:echats/coord/Axis} axis\r\n * @param {module:echarts/model/Model} tickModel For example, can be axisTick, splitLine, splitArea.\r\n * @return {Object} {\r\n *     ticks: Array.<number>\r\n *     tickCategoryInterval: number\r\n * }\r\n */\r\n\r\nexport function createAxisTicks(axis, tickModel) {\r\n  // Only ordinal scale support tick interval\r\n  return axis.type === 'category' ? makeCategoryTicks(axis, tickModel) : {\r\n    ticks: zrUtil.map(axis.scale.getTicks(), function (tick) {\r\n      return tick.value;\r\n    })\r\n  };\r\n}\r\n\r\nfunction makeCategoryLabels(axis) {\r\n  var labelModel = axis.getLabelModel();\r\n  var result = makeCategoryLabelsActually(axis, labelModel);\r\n  return !labelModel.get('show') || axis.scale.isBlank() ? {\r\n    labels: [],\r\n    labelCategoryInterval: result.labelCategoryInterval\r\n  } : result;\r\n}\r\n\r\nfunction makeCategoryLabelsActually(axis, labelModel) {\r\n  var labelsCache = getListCache(axis, 'labels');\r\n  var optionLabelInterval = getOptionCategoryInterval(labelModel);\r\n  var result = listCacheGet(labelsCache, optionLabelInterval);\r\n\r\n  if (result) {\r\n    return result;\r\n  }\r\n\r\n  var labels;\r\n  var numericLabelInterval;\r\n\r\n  if (zrUtil.isFunction(optionLabelInterval)) {\r\n    labels = makeLabelsByCustomizedCategoryInterval(axis, optionLabelInterval);\r\n  } else {\r\n    numericLabelInterval = optionLabelInterval === 'auto' ? makeAutoCategoryInterval(axis) : optionLabelInterval;\r\n    labels = makeLabelsByNumericCategoryInterval(axis, numericLabelInterval);\r\n  } // Cache to avoid calling interval function repeatedly.\r\n\r\n\r\n  return listCacheSet(labelsCache, optionLabelInterval, {\r\n    labels: labels,\r\n    labelCategoryInterval: numericLabelInterval\r\n  });\r\n}\r\n\r\nfunction makeCategoryTicks(axis, tickModel) {\r\n  var ticksCache = getListCache(axis, 'ticks');\r\n  var optionTickInterval = getOptionCategoryInterval(tickModel);\r\n  var result = listCacheGet(ticksCache, optionTickInterval);\r\n\r\n  if (result) {\r\n    return result;\r\n  }\r\n\r\n  var ticks;\r\n  var tickCategoryInterval; // Optimize for the case that large category data and no label displayed,\r\n  // we should not return all ticks.\r\n\r\n  if (!tickModel.get('show') || axis.scale.isBlank()) {\r\n    ticks = [];\r\n  }\r\n\r\n  if (zrUtil.isFunction(optionTickInterval)) {\r\n    ticks = makeLabelsByCustomizedCategoryInterval(axis, optionTickInterval, true);\r\n  } // Always use label interval by default despite label show. Consider this\r\n  // scenario, Use multiple grid with the xAxis sync, and only one xAxis shows\r\n  // labels. `splitLine` and `axisTick` should be consistent in this case.\r\n  else if (optionTickInterval === 'auto') {\r\n      var labelsResult = makeCategoryLabelsActually(axis, axis.getLabelModel());\r\n      tickCategoryInterval = labelsResult.labelCategoryInterval;\r\n      ticks = zrUtil.map(labelsResult.labels, function (labelItem) {\r\n        return labelItem.tickValue;\r\n      });\r\n    } else {\r\n      tickCategoryInterval = optionTickInterval;\r\n      ticks = makeLabelsByNumericCategoryInterval(axis, tickCategoryInterval, true);\r\n    } // Cache to avoid calling interval function repeatedly.\r\n\r\n\r\n  return listCacheSet(ticksCache, optionTickInterval, {\r\n    ticks: ticks,\r\n    tickCategoryInterval: tickCategoryInterval\r\n  });\r\n}\r\n\r\nfunction makeRealNumberLabels(axis) {\r\n  var ticks = axis.scale.getTicks();\r\n  var labelFormatter = makeLabelFormatter(axis);\r\n  return {\r\n    labels: zrUtil.map(ticks, function (tick, idx) {\r\n      return {\r\n        level: tick.level,\r\n        formattedLabel: labelFormatter(tick, idx),\r\n        rawLabel: axis.scale.getLabel(tick),\r\n        tickValue: tick.value\r\n      };\r\n    })\r\n  };\r\n}\r\n\r\nfunction getListCache(axis, prop) {\r\n  // Because key can be a function, and cache size always is small, we use array cache.\r\n  return inner(axis)[prop] || (inner(axis)[prop] = []);\r\n}\r\n\r\nfunction listCacheGet(cache, key) {\r\n  for (var i = 0; i < cache.length; i++) {\r\n    if (cache[i].key === key) {\r\n      return cache[i].value;\r\n    }\r\n  }\r\n}\r\n\r\nfunction listCacheSet(cache, key, value) {\r\n  cache.push({\r\n    key: key,\r\n    value: value\r\n  });\r\n  return value;\r\n}\r\n\r\nfunction makeAutoCategoryInterval(axis) {\r\n  var result = inner(axis).autoInterval;\r\n  return result != null ? result : inner(axis).autoInterval = axis.calculateCategoryInterval();\r\n}\r\n/**\r\n * Calculate interval for category axis ticks and labels.\r\n * To get precise result, at least one of `getRotate` and `isHorizontal`\r\n * should be implemented in axis.\r\n */\r\n\r\n\r\nexport function calculateCategoryInterval(axis) {\r\n  var params = fetchAutoCategoryIntervalCalculationParams(axis);\r\n  var labelFormatter = makeLabelFormatter(axis);\r\n  var rotation = (params.axisRotate - params.labelRotate) / 180 * Math.PI;\r\n  var ordinalScale = axis.scale;\r\n  var ordinalExtent = ordinalScale.getExtent(); // Providing this method is for optimization:\r\n  // avoid generating a long array by `getTicks`\r\n  // in large category data case.\r\n\r\n  var tickCount = ordinalScale.count();\r\n\r\n  if (ordinalExtent[1] - ordinalExtent[0] < 1) {\r\n    return 0;\r\n  }\r\n\r\n  var step = 1; // Simple optimization. Empirical value: tick count should less than 40.\r\n\r\n  if (tickCount > 40) {\r\n    step = Math.max(1, Math.floor(tickCount / 40));\r\n  }\r\n\r\n  var tickValue = ordinalExtent[0];\r\n  var unitSpan = axis.dataToCoord(tickValue + 1) - axis.dataToCoord(tickValue);\r\n  var unitW = Math.abs(unitSpan * Math.cos(rotation));\r\n  var unitH = Math.abs(unitSpan * Math.sin(rotation));\r\n  var maxW = 0;\r\n  var maxH = 0; // Caution: Performance sensitive for large category data.\r\n  // Consider dataZoom, we should make appropriate step to avoid O(n) loop.\r\n\r\n  for (; tickValue <= ordinalExtent[1]; tickValue += step) {\r\n    var width = 0;\r\n    var height = 0; // Not precise, do not consider align and vertical align\r\n    // and each distance from axis line yet.\r\n\r\n    var rect = textContain.getBoundingRect(labelFormatter({\r\n      value: tickValue\r\n    }), params.font, 'center', 'top'); // Magic number\r\n\r\n    width = rect.width * 1.3;\r\n    height = rect.height * 1.3; // Min size, void long loop.\r\n\r\n    maxW = Math.max(maxW, width, 7);\r\n    maxH = Math.max(maxH, height, 7);\r\n  }\r\n\r\n  var dw = maxW / unitW;\r\n  var dh = maxH / unitH; // 0/0 is NaN, 1/0 is Infinity.\r\n\r\n  isNaN(dw) && (dw = Infinity);\r\n  isNaN(dh) && (dh = Infinity);\r\n  var interval = Math.max(0, Math.floor(Math.min(dw, dh)));\r\n  var cache = inner(axis.model);\r\n  var axisExtent = axis.getExtent();\r\n  var lastAutoInterval = cache.lastAutoInterval;\r\n  var lastTickCount = cache.lastTickCount; // Use cache to keep interval stable while moving zoom window,\r\n  // otherwise the calculated interval might jitter when the zoom\r\n  // window size is close to the interval-changing size.\r\n  // For example, if all of the axis labels are `a, b, c, d, e, f, g`.\r\n  // The jitter will cause that sometimes the displayed labels are\r\n  // `a, d, g` (interval: 2) sometimes `a, c, e`(interval: 1).\r\n\r\n  if (lastAutoInterval != null && lastTickCount != null && Math.abs(lastAutoInterval - interval) <= 1 && Math.abs(lastTickCount - tickCount) <= 1 // Always choose the bigger one, otherwise the critical\r\n  // point is not the same when zooming in or zooming out.\r\n  && lastAutoInterval > interval // If the axis change is caused by chart resize, the cache should not\r\n  // be used. Otherwise some hidden labels might not be shown again.\r\n  && cache.axisExtent0 === axisExtent[0] && cache.axisExtent1 === axisExtent[1]) {\r\n    interval = lastAutoInterval;\r\n  } // Only update cache if cache not used, otherwise the\r\n  // changing of interval is too insensitive.\r\n  else {\r\n      cache.lastTickCount = tickCount;\r\n      cache.lastAutoInterval = interval;\r\n      cache.axisExtent0 = axisExtent[0];\r\n      cache.axisExtent1 = axisExtent[1];\r\n    }\r\n\r\n  return interval;\r\n}\r\n\r\nfunction fetchAutoCategoryIntervalCalculationParams(axis) {\r\n  var labelModel = axis.getLabelModel();\r\n  return {\r\n    axisRotate: axis.getRotate ? axis.getRotate() : axis.isHorizontal && !axis.isHorizontal() ? 90 : 0,\r\n    labelRotate: labelModel.get('rotate') || 0,\r\n    font: labelModel.getFont()\r\n  };\r\n}\r\n\r\nfunction makeLabelsByNumericCategoryInterval(axis, categoryInterval, onlyTick) {\r\n  var labelFormatter = makeLabelFormatter(axis);\r\n  var ordinalScale = axis.scale;\r\n  var ordinalExtent = ordinalScale.getExtent();\r\n  var labelModel = axis.getLabelModel();\r\n  var result = []; // TODO: axisType: ordinalTime, pick the tick from each month/day/year/...\r\n\r\n  var step = Math.max((categoryInterval || 0) + 1, 1);\r\n  var startTick = ordinalExtent[0];\r\n  var tickCount = ordinalScale.count(); // Calculate start tick based on zero if possible to keep label consistent\r\n  // while zooming and moving while interval > 0. Otherwise the selection\r\n  // of displayable ticks and symbols probably keep changing.\r\n  // 3 is empirical value.\r\n\r\n  if (startTick !== 0 && step > 1 && tickCount / step > 2) {\r\n    startTick = Math.round(Math.ceil(startTick / step) * step);\r\n  } // (1) Only add min max label here but leave overlap checking\r\n  // to render stage, which also ensure the returned list\r\n  // suitable for splitLine and splitArea rendering.\r\n  // (2) Scales except category always contain min max label so\r\n  // do not need to perform this process.\r\n\r\n\r\n  var showAllLabel = shouldShowAllLabels(axis);\r\n  var includeMinLabel = labelModel.get('showMinLabel') || showAllLabel;\r\n  var includeMaxLabel = labelModel.get('showMaxLabel') || showAllLabel;\r\n\r\n  if (includeMinLabel && startTick !== ordinalExtent[0]) {\r\n    addItem(ordinalExtent[0]);\r\n  } // Optimize: avoid generating large array by `ordinalScale.getTicks()`.\r\n\r\n\r\n  var tickValue = startTick;\r\n\r\n  for (; tickValue <= ordinalExtent[1]; tickValue += step) {\r\n    addItem(tickValue);\r\n  }\r\n\r\n  if (includeMaxLabel && tickValue - step !== ordinalExtent[1]) {\r\n    addItem(ordinalExtent[1]);\r\n  }\r\n\r\n  function addItem(tickValue) {\r\n    var tickObj = {\r\n      value: tickValue\r\n    };\r\n    result.push(onlyTick ? tickValue : {\r\n      formattedLabel: labelFormatter(tickObj),\r\n      rawLabel: ordinalScale.getLabel(tickObj),\r\n      tickValue: tickValue\r\n    });\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nfunction makeLabelsByCustomizedCategoryInterval(axis, categoryInterval, onlyTick) {\r\n  var ordinalScale = axis.scale;\r\n  var labelFormatter = makeLabelFormatter(axis);\r\n  var result = [];\r\n  zrUtil.each(ordinalScale.getTicks(), function (tick) {\r\n    var rawLabel = ordinalScale.getLabel(tick);\r\n    var tickValue = tick.value;\r\n\r\n    if (categoryInterval(tick.value, rawLabel)) {\r\n      result.push(onlyTick ? tickValue : {\r\n        formattedLabel: labelFormatter(tick),\r\n        rawLabel: rawLabel,\r\n        tickValue: tickValue\r\n      });\r\n    }\r\n  });\r\n  return result;\r\n}", "\r\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\r\n\r\n\r\n/**\r\n * AUTO-GENERATED FILE. DO NOT MODIFY.\r\n */\r\n\r\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\r\nimport { each, map } from 'zrender/lib/core/util.js';\r\nimport { linearMap, getPixelPrecision, round } from '../util/number.js';\r\nimport { createAxisTicks, createAxisLabels, calculateCategoryInterval } from './axisTickLabelBuilder.js';\r\nvar NORMALIZED_EXTENT = [0, 1];\r\n/**\r\n * Base class of Axis.\r\n */\r\n\r\nvar Axis =\r\n/** @class */\r\nfunction () {\r\n  function Axis(dim, scale, extent) {\r\n    this.onBand = false;\r\n    this.inverse = false;\r\n    this.dim = dim;\r\n    this.scale = scale;\r\n    this._extent = extent || [0, 0];\r\n  }\r\n  /**\r\n   * If axis extent contain given coord\r\n   */\r\n\r\n\r\n  Axis.prototype.contain = function (coord) {\r\n    var extent = this._extent;\r\n    var min = Math.min(extent[0], extent[1]);\r\n    var max = Math.max(extent[0], extent[1]);\r\n    return coord >= min && coord <= max;\r\n  };\r\n  /**\r\n   * If axis extent contain given data\r\n   */\r\n\r\n\r\n  Axis.prototype.containData = function (data) {\r\n    return this.scale.contain(data);\r\n  };\r\n  /**\r\n   * Get coord extent.\r\n   */\r\n\r\n\r\n  Axis.prototype.getExtent = function () {\r\n    return this._extent.slice();\r\n  };\r\n  /**\r\n   * Get precision used for formatting\r\n   */\r\n\r\n\r\n  Axis.prototype.getPixelPrecision = function (dataExtent) {\r\n    return getPixelPrecision(dataExtent || this.scale.getExtent(), this._extent);\r\n  };\r\n  /**\r\n   * Set coord extent\r\n   */\r\n\r\n\r\n  Axis.prototype.setExtent = function (start, end) {\r\n    var extent = this._extent;\r\n    extent[0] = start;\r\n    extent[1] = end;\r\n  };\r\n  /**\r\n   * Convert data to coord. Data is the rank if it has an ordinal scale\r\n   */\r\n\r\n\r\n  Axis.prototype.dataToCoord = function (data, clamp) {\r\n    var extent = this._extent;\r\n    var scale = this.scale;\r\n    data = scale.normalize(data);\r\n\r\n    if (this.onBand && scale.type === 'ordinal') {\r\n      extent = extent.slice();\r\n      fixExtentWithBands(extent, scale.count());\r\n    }\r\n\r\n    return linearMap(data, NORMALIZED_EXTENT, extent, clamp);\r\n  };\r\n  /**\r\n   * Convert coord to data. Data is the rank if it has an ordinal scale\r\n   */\r\n\r\n\r\n  Axis.prototype.coordToData = function (coord, clamp) {\r\n    var extent = this._extent;\r\n    var scale = this.scale;\r\n\r\n    if (this.onBand && scale.type === 'ordinal') {\r\n      extent = extent.slice();\r\n      fixExtentWithBands(extent, scale.count());\r\n    }\r\n\r\n    var t = linearMap(coord, extent, NORMALIZED_EXTENT, clamp);\r\n    return this.scale.scale(t);\r\n  };\r\n  /**\r\n   * Convert pixel point to data in axis\r\n   */\r\n\r\n\r\n  Axis.prototype.pointToData = function (point, clamp) {\r\n    // Should be implemented in derived class if necessary.\r\n    return;\r\n  };\r\n  /**\r\n   * Different from `zrUtil.map(axis.getTicks(), axis.dataToCoord, axis)`,\r\n   * `axis.getTicksCoords` considers `onBand`, which is used by\r\n   * `boundaryGap:true` of category axis and splitLine and splitArea.\r\n   * @param opt.tickModel default: axis.model.getModel('axisTick')\r\n   * @param opt.clamp If `true`, the first and the last\r\n   *        tick must be at the axis end points. Otherwise, clip ticks\r\n   *        that outside the axis extent.\r\n   */\r\n\r\n\r\n  Axis.prototype.getTicksCoords = function (opt) {\r\n    opt = opt || {};\r\n    var tickModel = opt.tickModel || this.getTickModel();\r\n    var result = createAxisTicks(this, tickModel);\r\n    var ticks = result.ticks;\r\n    var ticksCoords = map(ticks, function (tickVal) {\r\n      return {\r\n        coord: this.dataToCoord(this.scale.type === 'ordinal' ? this.scale.getRawOrdinalNumber(tickVal) : tickVal),\r\n        tickValue: tickVal\r\n      };\r\n    }, this);\r\n    var alignWithLabel = tickModel.get('alignWithLabel');\r\n    fixOnBandTicksCoords(this, ticksCoords, alignWithLabel, opt.clamp);\r\n    return ticksCoords;\r\n  };\r\n\r\n  Axis.prototype.getMinorTicksCoords = function () {\r\n    if (this.scale.type === 'ordinal') {\r\n      // Category axis doesn't support minor ticks\r\n      return [];\r\n    }\r\n\r\n    var minorTickModel = this.model.getModel('minorTick');\r\n    var splitNumber = minorTickModel.get('splitNumber'); // Protection.\r\n\r\n    if (!(splitNumber > 0 && splitNumber < 100)) {\r\n      splitNumber = 5;\r\n    }\r\n\r\n    var minorTicks = this.scale.getMinorTicks(splitNumber);\r\n    var minorTicksCoords = map(minorTicks, function (minorTicksGroup) {\r\n      return map(minorTicksGroup, function (minorTick) {\r\n        return {\r\n          coord: this.dataToCoord(minorTick),\r\n          tickValue: minorTick\r\n        };\r\n      }, this);\r\n    }, this);\r\n    return minorTicksCoords;\r\n  };\r\n\r\n  Axis.prototype.getViewLabels = function () {\r\n    return createAxisLabels(this).labels;\r\n  };\r\n\r\n  Axis.prototype.getLabelModel = function () {\r\n    return this.model.getModel('axisLabel');\r\n  };\r\n  /**\r\n   * Notice here we only get the default tick model. For splitLine\r\n   * or splitArea, we should pass the splitLineModel or splitAreaModel\r\n   * manually when calling `getTicksCoords`.\r\n   * In GL, this method may be overridden to:\r\n   * `axisModel.getModel('axisTick', grid3DModel.getModel('axisTick'));`\r\n   */\r\n\r\n\r\n  Axis.prototype.getTickModel = function () {\r\n    return this.model.getModel('axisTick');\r\n  };\r\n  /**\r\n   * Get width of band\r\n   */\r\n\r\n\r\n  Axis.prototype.getBandWidth = function () {\r\n    var axisExtent = this._extent;\r\n    var dataExtent = this.scale.getExtent();\r\n    var len = dataExtent[1] - dataExtent[0] + (this.onBand ? 1 : 0); // Fix #2728, avoid NaN when only one data.\r\n\r\n    len === 0 && (len = 1);\r\n    var size = Math.abs(axisExtent[1] - axisExtent[0]);\r\n    return Math.abs(size) / len;\r\n  };\r\n  /**\r\n   * Only be called in category axis.\r\n   * Can be overridden, consider other axes like in 3D.\r\n   * @return Auto interval for cateogry axis tick and label\r\n   */\r\n\r\n\r\n  Axis.prototype.calculateCategoryInterval = function () {\r\n    return calculateCategoryInterval(this);\r\n  };\r\n\r\n  return Axis;\r\n}();\r\n\r\nfunction fixExtentWithBands(extent, nTick) {\r\n  var size = extent[1] - extent[0];\r\n  var len = nTick;\r\n  var margin = size / len / 2;\r\n  extent[0] += margin;\r\n  extent[1] -= margin;\r\n} // If axis has labels [1, 2, 3, 4]. Bands on the axis are\r\n// |---1---|---2---|---3---|---4---|.\r\n// So the displayed ticks and splitLine/splitArea should between\r\n// each data item, otherwise cause misleading (e.g., split tow bars\r\n// of a single data item when there are two bar series).\r\n// Also consider if tickCategoryInterval > 0 and onBand, ticks and\r\n// splitLine/spliteArea should layout appropriately corresponding\r\n// to displayed labels. (So we should not use `getBandWidth` in this\r\n// case).\r\n\r\n\r\nfunction fixOnBandTicksCoords(axis, ticksCoords, alignWithLabel, clamp) {\r\n  var ticksLen = ticksCoords.length;\r\n\r\n  if (!axis.onBand || alignWithLabel || !ticksLen) {\r\n    return;\r\n  }\r\n\r\n  var axisExtent = axis.getExtent();\r\n  var last;\r\n  var diffSize;\r\n\r\n  if (ticksLen === 1) {\r\n    ticksCoords[0].coord = axisExtent[0];\r\n    last = ticksCoords[1] = {\r\n      coord: axisExtent[0]\r\n    };\r\n  } else {\r\n    var crossLen = ticksCoords[ticksLen - 1].tickValue - ticksCoords[0].tickValue;\r\n    var shift_1 = (ticksCoords[ticksLen - 1].coord - ticksCoords[0].coord) / crossLen;\r\n    each(ticksCoords, function (ticksItem) {\r\n      ticksItem.coord -= shift_1 / 2;\r\n    });\r\n    var dataExtent = axis.scale.getExtent();\r\n    diffSize = 1 + dataExtent[1] - ticksCoords[ticksLen - 1].tickValue;\r\n    last = {\r\n      coord: ticksCoords[ticksLen - 1].coord + shift_1 * diffSize\r\n    };\r\n    ticksCoords.push(last);\r\n  }\r\n\r\n  var inverse = axisExtent[0] > axisExtent[1]; // Handling clamp.\r\n\r\n  if (littleThan(ticksCoords[0].coord, axisExtent[0])) {\r\n    clamp ? ticksCoords[0].coord = axisExtent[0] : ticksCoords.shift();\r\n  }\r\n\r\n  if (clamp && littleThan(axisExtent[0], ticksCoords[0].coord)) {\r\n    ticksCoords.unshift({\r\n      coord: axisExtent[0]\r\n    });\r\n  }\r\n\r\n  if (littleThan(axisExtent[1], last.coord)) {\r\n    clamp ? last.coord = axisExtent[1] : ticksCoords.pop();\r\n  }\r\n\r\n  if (clamp && littleThan(last.coord, axisExtent[1])) {\r\n    ticksCoords.push({\r\n      coord: axisExtent[1]\r\n    });\r\n  }\r\n\r\n  function littleThan(a, b) {\r\n    // Avoid rounding error cause calculated tick coord different with extent.\r\n    // It may cause an extra unnecessary tick added.\r\n    a = round(a);\r\n    b = round(b);\r\n    return inverse ? a > b : a < b;\r\n  }\r\n}\r\n\r\nexport default Axis;", "\r\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\r\n\r\n\r\n/**\r\n * AUTO-GENERATED FILE. DO NOT MODIFY.\r\n */\r\n\r\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\r\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\r\nvar AxisModelCommonMixin =\r\n/** @class */\r\nfunction () {\r\n  function AxisModelCommonMixin() {}\r\n\r\n  AxisModelCommonMixin.prototype.getNeedCrossZero = function () {\r\n    var option = this.option;\r\n    return !option.scale;\r\n  };\r\n  /**\r\n   * Should be implemented by each axis model if necessary.\r\n   * @return coordinate system model\r\n   */\r\n\r\n\r\n  AxisModelCommonMixin.prototype.getCoordSysModel = function () {\r\n    return;\r\n  };\r\n\r\n  return AxisModelCommonMixin;\r\n}();\r\n\r\nexport { AxisModelCommonMixin };"],
  "mappings": "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",
  "names": ["min", "max", "Region", "GeoJSONPolygonGeometry", "GeoJSONLineStringGeometry", "GeoJSONRegion", "min", "max", "GeoSVGRegion", "tickValue", "Axis", "min", "max", "AxisModelCommonMixin"]
}
